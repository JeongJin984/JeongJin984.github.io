<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://JeongJin984.github.io</id><title>Jiny</title><subtitle>Jiny's Information</subtitle> <updated>2021-06-06T16:31:34+09:00</updated> <author> <name>Nam Jeong Jin</name> <uri>https://JeongJin984.github.io</uri> </author><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="https://JeongJin984.github.io" rel="alternate" type="text/html" /> <generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator> <rights> © 2021 Nam Jeong Jin </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Operation System 3 thread 2</title><link href="https://JeongJin984.github.io/posts/Operation-System-3-thread-2/" rel="alternate" type="text/html" title="Operation System 3 thread 2" /><published>2021-06-06T15:30:00+09:00</published> <updated>2021-06-06T15:30:00+09:00</updated> <id>https://JeongJin984.github.io/posts/Operation-System-3-thread-2/</id> <content src="https://JeongJin984.github.io/posts/Operation-System-3-thread-2/" /> <author> <name>Nam Jeong Jin</name> </author> <category term="CS" /> <category term="OS" /> <summary> Operation System 3(스레드 2) 💿 Dead Lock(교착 상태) 스레드(혹은 프로세스)가 자원을 얻지 못해서 다음 처리를 못하는 상태 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생 🔔 주의 밑에서 나오는 모든 프로세스에 대한 것은 스레드에도 똑같이 해당되는 내용임 즉 프로세스 = 프로세스 + 스레드 데드락이 일어나는 경우 프로세스1과 2가 자원1,2를 모두 얻어야 한다고 가정해보자 t1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음 t2 : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림 즉 현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠짐 멀티 프... </summary> </entry> <entry><title>Operation System 6 file</title><link href="https://JeongJin984.github.io/posts/Operation-System-7-file/" rel="alternate" type="text/html" title="Operation System 6 file" /><published>2021-06-05T15:30:00+09:00</published> <updated>2021-06-05T15:30:00+09:00</updated> <id>https://JeongJin984.github.io/posts/Operation-System-7-file/</id> <content src="https://JeongJin984.github.io/posts/Operation-System-7-file/" /> <author> <name>Nam Jeong Jin</name> </author> <category term="CS" /> <category term="OS" /> <summary> Operation System 6(파일 시스템) 💿 파일 운영체제의 저장장치의 물리적 특성을 추상화한 논리적 저장 단위 파일은 운영체제에 의해 물리 장치들로 맵핑되기도 하며, 일반적으로 비휘발적 특성을 지니기 때문에, 전원이 끊어진 상황에서도 정보들을 영구히 보존할 수 있다 프로그램 : 소스 프로그램, 목적 프로그램으로 나누어 진다. 자료 : 숫자,문자,이진수, 자유 형식이거나 정해진 형식 등, 저장할 수 있는 모든 것이 자료가 될 수 있다. 파일 속성 이름 : 사람이 읽을 수 있는 형태로 유지되는 유일한 정보 식별자 : 파일 시스템 내에서 파일을 식별하는 고유의 번호 PK 타입 : 여러 타입의 파일을 제공하는 시스템을 위해 필요 위치 : 장치 내에서 파... </summary> </entry> <entry><title>Operation System 6 Virtual Memory</title><link href="https://JeongJin984.github.io/posts/Operation-System-6-virtualMemoy-1/" rel="alternate" type="text/html" title="Operation System 6 Virtual Memory" /><published>2021-06-05T15:30:00+09:00</published> <updated>2021-06-05T15:30:00+09:00</updated> <id>https://JeongJin984.github.io/posts/Operation-System-6-virtualMemoy-1/</id> <content src="https://JeongJin984.github.io/posts/Operation-System-6-virtualMemoy-1/" /> <author> <name>Nam Jeong Jin</name> </author> <category term="CS" /> <category term="OS" /> <summary> Operation System 6(페이징) 💿 가상 메모리 메모리 과할당(over allocation) 즉 실제 메모리의 사이즈 보다 더 큰 사이즈의 메모리를 프로세스에 할당하기 위한 방법 프로세스의 모든 코드는 항상 필요한 것이 아니다. 필요한 부분만 메모리에 올림으로써 메인 메모리에 올라가는 프로세스의 크기를 줄인다.(동적 적재와 비슷) 페이징을 먼저 실행 메인 메모리의 외부 단편화를 해결하면 효율적이기 때문 여기서 필요한 부분과 필요없는 부분을 나눈다. 필요한 부분만 메모리에 적재 이를 요구 페이징이라고 한다. 요구페이징은 프로세스의 이미지를 backing store에 저장한다. backing store는 swap devic... </summary> </entry> <entry><title>Operation System 4 paging 2</title><link href="https://JeongJin984.github.io/posts/Operation-System-5-paging-2/" rel="alternate" type="text/html" title="Operation System 4 paging 2" /><published>2021-06-05T15:30:00+09:00</published> <updated>2021-06-05T15:30:00+09:00</updated> <id>https://JeongJin984.github.io/posts/Operation-System-5-paging-2/</id> <content src="https://JeongJin984.github.io/posts/Operation-System-5-paging-2/" /> <author> <name>Nam Jeong Jin</name> </author> <category term="CS" /> <category term="OS" /> <summary> Operation System 4(페이징) 💿 페이지 교체 알고리즘 현재 할당된 페이지 중 어떤 것 교체할 지 결정하는 방법 가상 메모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둠 하지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있음 따라서 메모리가 가득 차면, 추가로 페이지를 가져오기 위해서 안쓰는 페이지는 out하고, 해당 공간에 현재 필요한 페이지를 in 시켜야 함 여기서 어떤 페이지를 out 시켜야할 지 정해야 함. (이때 out 되는 페이지를 victim page라고 부름) 기왕이면 수정이 되지 않는 페이지를 선택해야 좋음 (Why? : 만약 ... </summary> </entry> <entry><title>Operation System 4 paging 1</title><link href="https://JeongJin984.github.io/posts/Operation-System-5-paging-1/" rel="alternate" type="text/html" title="Operation System 4 paging 1" /><published>2021-06-05T15:30:00+09:00</published> <updated>2021-06-05T15:30:00+09:00</updated> <id>https://JeongJin984.github.io/posts/Operation-System-5-paging-1/</id> <content src="https://JeongJin984.github.io/posts/Operation-System-5-paging-1/" /> <author> <name>Nam Jeong Jin</name> </author> <category term="CS" /> <category term="OS" /> <summary> Operation System 4(페이징) 💿 내부 단편화와 외부 단편화 내부 단편화 빈 공간이 50인데 들어간 프로세스가 30 이므로 20이라는 공간이 남음. 저 공간은 너무 작아서 사용하지 못함 외부 단편화 작업보다 많은 공간이 남아 있더라도 실제로 그 작업을 받아 들이지 못하는 경우 💿 페이징 과 세그먼테이션 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억 장치를 동적 분할하는 메모리 관리 작업이 필요 메모리 관리 기법 연속 메모리 관리: 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당 고정 분할 기법: 주기억장치가 고정된 파티션으로 분할(내부 단편화) 동적 문할 기법: 파티션들이 동적 생성되며... </summary> </entry> </feed>
