---
title: Operation System 4 paging 1
author: Jiny
date: 2021-06-06 13:30:00 +0800
categories: [CS, OS]
tags: [cs, os, paging]
toc: false
---
 
# Operation System 4(페이징)
___

## 💿 **내부 단편화와 외부 단편화**

### **내부 단편화**

![image](https://mblogthumb-phinf.pstatic.net/20160211_63/rbdi3222_1455175332562aT255_JPEG/%B3%BB%BA%CE%B4%DC%C6%ED%C8%AD.JPG?type=w2)

> 빈 공간이 50인데 들어간 프로세스가 30 이므로 20이라는 공간이 남음. 저 공간은 너무 작아서 사용하지 못함

### **외부 단편화**
![image](https://mblogthumb-phinf.pstatic.net/20160211_249/rbdi3222_1455175332786x4fI1_JPEG/%BF%DC%BA%CE%B4%DC%C6%ED%C8%AD.JPG?type=w2)

> 작업보다 많은 공간이 남아 있더라도 실제로 그 작업을 받아 들이지 못하는 경우

___

## 💿 **페이징 과 세그먼테이션**

> 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억 장치를 동적 분할하는 메모리 관리 작업이 필요

### **메모리 관리 기법**

- 연속 메모리 관리: 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당
  - 고정 분할 기법: 주기억장치가 고정된 파티션으로 분할(내부 단편화)
  - 동적 문할 기법: 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재
- 불연속 메모리 관리: 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
  - 페이지: 고정 사이즈의 작은 프로세스 조각
  - 프레임: 페이지 크기와 같은 주기억장치 메모리 조각
  - 단편화: 기억장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상(찾기 어려움)
  - 세그먼트: 서로 다른 크기를 가진 논리적 블럭이 연속적 공간에 배치되는 것(기본적으로 프로세스는 코드, 데이터, 스택 세가지 세그먼트를 가지고 있다.)

- 고정크기: 페이징(Paging)
- 가변크기: 세그먼테이션(Segmentation)
  - 단순 페이징
    - 각 프로세스는 프레임들과 같은 크기를 가진 균등 페이지로 나뉨
    - 외부 단편화X
    - 소량의 내부 단편화 발생
  - 단순 세그먼테이션
    - 각 프로세스는 여러 세그먼트들로 나뉨
    - 내부 단편화X
    - 외부 단편화 존재
  - 가상 메모리 페이징
    - 단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요X
    - 필요한 페이지가 있으면 나중에 자동으로 불러들어짐
    - 외부 단편화 X
    - 복잡한 메모리 관리로 오버헤드 발생
  - 가상 메모리 세그먼테이션
    - 필요하지 않은 세그먼트들은 로드되지 않음
    - 필요한 세그먼트 있을때 나중에 자동으로 불러들어짐
    - 내부 단편화X
    - 복잡한 메모리 관리로 오버헤드 발생

___

## 💿 **페이징**

![image](https://t1.daumcdn.net/cfile/tistory/27649A47590818AA2D)

> 프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재

메모리 공간을 할당할 때 코드에서 명명한 메모리 주소 위치와 다르게 임의로 프로세스를 메모리에 적재하였다. 이렇게 할 수 있는 이유는 바로 MMU의 재배치 레지스터 값을 바꾸어 CPU를 속일 수 있었기 때문이다.

프로세스를 나눈 페이지 마다 재배치 레지스터를 만들어 놓으면 CPU는 마치 불연속적인 메모리를 마치 연속적인 메모리 처럼 프로세스가 사용하고 있다고 생각

프로세스를 자르는 단위가 페이지 이고 이에 동일한 크기로 메모리를 자른 것을 프레임 페이징 에서 프로세스를 일정한 크기로 자르기 때문에 가능

이때  페이지를 관리하는 MMU는 **페이지 테이블**이 된다. 페이지 테이블 안에 있는 개수는 프로세스를 몇 등분 하는가에 따라 결정된다.

CPU가 만들어 내는 주소(PC)는 **논리 주소**라고 한다. MMU인 페이지 테이블을 통해 물리 주소로 바꾸어서 메모리에서 찾게 된다. 논리 주소는 m개의 비트로 하위 n 비트는 오프셋 또는 변위를 나타내고 상위의 (m-n)비트는 페이지 번호를 나타낸다.

페이징 과정을 진행하면 **내부 단편화**가 발생할 수 있다. 페이징은 프로세스를 특정 단위인 페이지 단위로 나누어 주고 된다. 하지만 프로세스의 크기가 페이지 크기의 배수가 아니라면 마지막 프로세스의 페이지는 한 프레임을 다 채울 수 없다. 

![image](https://t1.daumcdn.net/cfile/tistory/25666F47590818AA20)

1. 16바이트로 페이지를 나눈다고 생각하면 n은 4비트가 된다. 2진수로 표현된 값이기 때문이다.
2. 페이지 테이블에서 페이지 번호를 가져와서 해당하는 프레임 번호를 가져오게 된다. 
3. 페이지 번호는 페이지 테이블의 인덱스 값으로 인식한다. 
4. 페이지 번호에 해당하는 페이지 테이블의 값과 n비트의 값을 가진 물리 주소로 바뀌게 된다.

***예시***

페이지 사이즈가 4바이트이고 페이지 테이블에 페이지 번호 당 5, 6, 1, 2를 가진다고 한다. 

그러면 페이지 번호가 0번이면 5로 1번이면 6으로 가는 것으로 인식하면 된다. 

CPU가 논리 주소로 13번지를 요구한다면 메인 메모리의 어디의 물리 주소 위치로 가야하는가? 

13을 이진수로 표현하면 1101이 된다. 이 주소 값에서 페이지 사이즈가 4바이트이므로 변위는 하위 2비트가 된다. 

그러므로 나머지 상위 2비트는 페이지 번호가 된다. 페이지 번호가 11이므로 3이 된다. 그러므로 3에 해당하는 2라는 물리 주소 값으로 가게 된다. 

2는 이진수로 10이고 하위 비트 01을 붙여 물리 주소가 1001로 바뀌게 된다. 따라서 9번지에 실제 프로세스의 페이지가 위치하게 되는 것이다.

___

## 💿 **세그먼테이션**

![image](https://t1.daumcdn.net/cfile/tistory/257ACD42590C1D9412)

> 프로세스를 논리적 내용 단위인 세그먼트로 자르는 방법

- 프로세스를 어떻게 자르는가에 대한 방법 빼고 메모리에 할당하는 방법에 대해서는 페이징과 방법이 같다. 
- 즉 MMU 내의 재배치 레지스터를 이용하여 논리 주소를 물리 주소로 바꾸는 방법은 같다.
  - 논리 주소에서 보내는 주소 값에서 하위 변위 비트를 제외한 앞의 비트들은 페이징 번호가 아니라 세그먼트 번호가 되는 것

![image](https://t1.daumcdn.net/cfile/tistory/22255E42590C1D9607)

세그먼트 테이블에 논리 주소 값이 들어가게 되면 세그먼트 번호는 세그먼트 테이블의 인덱스 값으로 인식을 하게 된다. 

세그먼트 번호를 토대로 테이블 내용으로 들어가 시작 위치 및 한계 값을 파악한다. 물리 주소는 세그먼트 테이블에 있는 시작 위치와 변위 값을 합하여 구할 수 있다. 

그런데 이런 주소 값이 한계(각 세그먼트의 크기)를 넘어서면 segment violation 예외 상황 처리를 하게 된다. 이런 경우는 변위가 한계보다 크면 발생한다.

세그먼테이션의 경우에도 보호와 공유의 기능을 수행하고 있다. 모든 논리 주소들은 세그먼테이션 테이블을 경우하게 되므로 세그먼트 테이블 엔트리마다 r, w, x 비트를 만들어 해당 세그먼트에 대한 접근 제어를 가능하게 해준다. 

사용하는 복수 개의 프로세스가 있다면 메모리에 하나만 적재하여 프로세서의 세그먼트 테이블 코드 영역이 같은 곳을 가리키게 만든다. 

페이징은 프로세스를 같은 단위로 자르게 되므로 중요한 부분과 중요하지 않은 부분이 같은 페이지 안으로 잘라질 수 있다. 또한 코드 영역 또한 같은 단위로 잘리므로 애매하게 잘려질 확률이 있다. 하지만 세그먼테이션의 방법으로 자르게 되면 코드 영역은 코드 영역으로 잘리게 되고 중요한 세그먼트, 중요하지 않은 세그먼트를 논리적인 내용 측면으로 자를 수 있다.

하지만 앞에서 말한 외부 단편화가 발생할 수 있다.

따라서 세그먼트를 페이징 하는 방법을 취한다.

프로세스를 처음에 세그먼트 단위로 자른다. 의미 있는 단위로 나누게 되면 보호와 공유를 하는 측면에 이점을 가질 수 있게 된다. 하지만 앞서 말했듯 외부 단편화가 발생할 수 있다. 그래서 우리는 잘라진 세그먼트를 다시 일정 간격인 페이지 단위로 자르는 페이징 방법을 취한다.

테이블을 두 가지를 모두 거쳐야 하므로 속도 면에서 조금 떨어질 수 있다.