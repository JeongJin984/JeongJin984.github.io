---
title: Operation System 2 process 1
author: Jiny
date: 2021-06-05 14:30:00 +0800
categories: [CS, OS]
tags: [cs, os, process]
toc: false
---
 
# Operation System 2(프로세스 1)
___

![image](https://gmlwjd9405.github.io/images/os-process-and-thread/thread.png)

> 프로세스: 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
> 
> 스레드: 프로세스 안에서 실행되는 여러 흐름 단위
>
> 커널: 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 메모리에 상주하는 운영체제의 부분을 커널이라고 함

## 💿 **역할**

프로세스는 독립적인 주소공간 할당(공유 메모리가 따로 존재함)

- Code: 코드 자체를 구성하는 메모리 영역(프로그램 명령)
- Data: 전역변수, 정적변수, 배열 등
  - 초기화 된 데이터는 data  영역에 저장
  - 초기화 되지 않은 데이터는 bss 영역에 저장
- Heap: 동적 할당 시 사용(new, malloc 등)
- Stack: 지역변수, 매개변수, 리턴 값(임시 메모리 영역)
  - 스레드는 Stack만 독립적인 주소공간으로 할당

즉 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하지만, 스레드는 다른 스레드와 공간, 자원을 공유하면서 사용한다는 차이가 존재
___

## 💿 **프로세스 상태**

![image](https://hyuntaekhong.github.io/assets/images/os/os05.png)

> 커널 내에는 준비 큐, 대기 큐, 실행 큐 등의 자료 구조가 있으며 커널은 이것들을 이용하여 프로세스의 상태를 관리한다.

- 생성상태 > 준비 상태
  - 미리 정의된 정책에 따라 스케줄러에 의해 호출, 이때 메모리의 이용 가능성과 어떤 장치가 요구되는지를 검사한다.
- 준비상태 > 실행 상태
  - 사전에 정의된 알고리즘(FCFS,RR, SRT등)에 따라 스케줄러에 의해 처리됨. 이를 dispatch라고 한다.
- 실행상태 > 대기상태
  - READ, WRITE 또는 다른 I/O 요구, 페이지 교환을 요구하는 작업 같은 명령 등에 의하여 일어난다.
  - 이러한 작업은 상대적으로 오랜 시간이 걸리기 때문에 그동안 CPU를 다른 프로세스에 할당하여 활용하기 위함이다.
- 대기상태 > 준비상태
  - I/O 장치 관리자의 신호에 의해 일어난다.
  - 페이지 교환의 경우 페이지 인터럽트 핸들러가 메모리에 그 페이지가 있다는 신호를 보내게 되며, 프로세스는 준비 큐에 놓이게 된다.
- 실행상태 > 종료상태
  - 프로세스를 성공적으로 끝마친 경우, 혹은 운영체제가 에러발생을 감지하고 프로세스를 강제로 종료시킨 경우에 스케줄러에 의해 실행된다.
  
___

## 💿 **프로세스 제어블록(Process Control Block, PCB)**

> 프로세스 관리를 위해 운영체제는 프로세스 제어블럭에 정보를 저장한다.

> PCB들은 LinkedList 형식으로 관리된다.
> PCB List Head에 PCB들이 생성될 때마다 붙게 된다. 
> 
> 주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이함.

즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료시 제거됨

![image](https://hyuntaekhong.github.io/assets/images/os/os06.png)

- 프로세스 상태
  - 프로세스의 현재 상태
- 프로세스 번호(PID)
  - 프로세스의 구분 기준이 되는 ID를 나타낸다.
- 프로그램 카운터(PC)
  - 프로세스 수행을 위한 다음 명령의 주소를 표시한다.
- 레지스터(Register)
  - 실행 상태에서 다른 상태로 전이되는 경우 CPU의 레지스터 정보를 이곳에 저장시켜서 나중에 다시 실행상태로 전이될 때 복구 시켜 프로세스의 정확한 수행을 이어간다,
- 메모리
  - 프로세스가 저장된 주소와 가상 메모리를 사용하는 경우에는 가상주소와 실제주소 사이의 사상(mapping)정보, 기준 레지스터(base Register)와 경계 레지스터(bound Register)등의 정보를 포함한다.
- 프로세스 우선순위
  - 시스템에 의해 이용, 스케줄링 시 어떤 작업을 선택할 것인가를 결정
- 회계 정보
  - 성능 측정과 순위에 대한 목적을 위한 정보이다.
  - CPU 사용시간, 프로세스의 시스템 존재 시간, 메모리 용량, 보조기억장치 사용량, 그리고 기타 시스템 프로그램의 사용 실태 등 다양한 정보를 포함한다.

___

## 💿 **프로세스 생성과 종료**

- 프로세스 생성
  - 부모 프로세스는 실행과정 동안 프로세스 시스템의 호출을 이용하여 여러개의 자식 프로세스를 생성한다.
  - 프로세스 생성과 관련된 작업인 프로세스의 이름을 결정하고 프로세스 준비 큐에 삽입하여 프로세스에 초기 우선순위를 부여하고 프로세스에 대한 프로세스 제어 블록을 만든다.
  - 프로세스는 작업을 수행하기 위해 자원이 필요한데 자식 프로세스가 생성되면 운영체제로부터 직접 자원을 얻거나 부모 프로세스 자원의 일부를 얻는다.(과도한 서브 프로세스 생성으로 인한 과부하 방지)
  - 프로세스 생성시 물리적, 논리적 자원을 얻는 것 이외에도 몇몇 초기화 데이터가 부모에 의해 자식 프로세스로 전달된다.
- 프로세스 종료
  - 프로세스는 마지막 문장이 실행을 마쳤을 때 종료된다.(혹은 에러가 발생하거나)때 프로세스는 부모 프로세스에게 실행 결과를 되돌려 준다.
  - 부모 프로세스가 자식 프로세스 실행 종료시킬수 있는 경우
    - 자식 프로세스가 할당된 자원의 사용을 초과했을 경우
      - 이는 부모 프로세스가 자식의 상태를 조사할 수 있는 매커니즘이 필요
    - 자식 프로세스에게 할당된 자원이 더이상 필요하지 않은 경우

___

## 💿 **스케줄링 전략의 분류**

### **CPU 스케줄링 성능 척도**
1. Response Time
   - 작업이 처음 실행되기까지 걸린 시간
2. Turnaround Time
   - 실행 시간과 대기 시간을 모두 합한 시간으로 작업이 완료될 때 까지 걸린 시간


### **선점 스케줄링 정책**

> 어떤 프로세스가 CPU를 할당받아 실행 중에 있어도 다른 프로세스가 실행 중인 프로세스를 중지하고 CPU를 강제로 점유할 수 있다. 즉 모든 프로세스에게 CPU 사용시간을 동일하게 부여 할 수 있다.

- 진행중인 작업에 interrupt를 걸고 다른 작업에 CPU를 할당하는 전략
- 시간 할당 방식에서 주로 사용
- 높은 우선순위의 프로세스가 긴급할 경우에 유용
- 단점으로 경비가 많이 들고 오버헤드를 초래한다. 문맥교환의 문제가 발생하기도 함

즉 어떤 프로세스도 일정시간 이상 동안 연속해서 CPU를 점유할 수 없으므로 계산 위주 프로세스가 많이 적재되어 있다 하더라도 모든 프로세스의 반응 시간 성능을 평균 이상을 유지할 수 있음

**종류**

- FCFS 스케줄링(First Come First Served Scheduling)
  - 큐에 도착한 순서대로 CPU 할당
  - 실행 시간이 짧은 게 뒤로 가면 평균 대기 시간이 길어짐
- SJF 스케줄링(Shortest Job First Scheduling)
  - 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
  - FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리
- HRRN 스케줄링(Highest Response Ratio Next Scheduling)
  - 우선순위를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)
  - 우선순위 = (대기시간 + 실행시간) / (실행시간)

### **비선점 스케줄링 정책**

> 어떤 프로세스가 CPU를 할당 받으면 그 프로세스가 종료되거나 입출력 요구가 발생하여 **자발적**으로 중지될 때까지 계속 실행되도록 보장

- 프로세스가 CPU를 할당받아 실행이 시작되면 프로세스 자체가 I/O 인터럽트를 걸거나 프로세스를 종료할 때 까지 실행상태에 있는다.
- 비선점 스케줄링은 우선순위와 관계없이 모든 프로세스가 공정하게 순서에 따라 실행되도록 관리

**종류**

- RR 스케줄링(Round Robin Scheduling)
  - FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 Time Quantum 만큼 CPU를 할달 받음
    - Time Quantum or Time Slice : 실행의 최소 단위 시간
  - 할당 시간(Time Quantum)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가
- SRTF 스케줄링(Shortest Remaining-Time First Scheduling)
- RM 스케줄링(Rate Monotonic Scheduling)
- EDF 스케줄링(Earliest Deadline First Scheduling)

+ MultiLevel Queue(다단계 큐)
![image](https://user-images.githubusercontent.com/13609011/91695428-16a2f480-eba9-11ea-8d91-17d22bab01e5.png)
  - 작업들을 여러 종류의 그룹으로 나누어 여러개의 큐를 이용
  - 우선 순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 Time Quantum을 설정 해주는 방식 사용
  - 우선 순위가 높은 큐는 작은 Time Quantum 할당. 낮은 큐는 큰 거에 할당
![image](https://user-images.githubusercontent.com/13609011/91695480-2a4e5b00-eba9-11ea-8dbf-390bf0a73c10.png)

+ MultiLevel-Feedback-Queue(다단계 피드백 큐)
![image](https://user-images.githubusercontent.com/13609011/91695489-2cb0b500-eba9-11ea-8578-6602fee742ed.png)
  - 다단계 큐에서 자신의 Time Quantum을 다 채운 프로세스는 밑으로 내려가고 그렇지 않으면 그대로
    - Time Quantum을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
  - 짧은 작업에 유리, 입출력 위주(Interrupt)가 잦은 작업에 우선권을 줌
  - 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌

___

## 💿 **인터럽트**

> 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것

- 내/외부 인터럽트: CPU 하드웨어 신호에 의해 발생
- 소프트웨어 인터럽트: 명령어의 수행에 의해 발생

### **외부 인터럽트**

> 입출력 장치, 타아밍 장치, 전원 등 외부적인 요인으로 발생

- 전원이상, 기계착오, 외부신호, 입출력

### **내부 인터럽트**

> Trap이라고 부르며, 잘못된 명령이나 데이터를 사용할 때

- 0 나누기, 오버플로우, 명령어를 잘못 사용한 경우(흔히 Exception이라 불리는 것들)

### **소프트웨어 인터럽트**

> 프로그램 처리 중 명령의 요청에 의해 발생한 것(SVC 인터럽트)

- 사용자가 프로그램을 실행시킬 때 발생
- 소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행됨(이를 위한 Interrupt)

### **인터럽트 처리**

> 마이크로프로세서는 인터럽트를 감지하면 지금 실행중인 기계어 코드를 중단하고 해당 인터럽트를 위한 처리 프로그램으로 점프하여 해당 일을 수행 한다. 인터럽트 처리를 위한 루틴을 인터럽트 서비스 루틴(ISR, Interrupt Service Routine)이라고 한다.

- 주 프로그램이 실행되다가 인터럽트가 발생했다.
  - 현재 수행중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다.(잠시 저장하는 이유는 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문)
  - 만약 인터럽트 기능이 없다면, 컨트롤러(OS)는 특정한 일을 할 시기를 알기 위해 계속 체크를 해야함(폴링 방식)

- 컨트롤러가 입력을 받아들이는 방법
  - 폴링 방식
    - 대상을 주기적으로 감시하여 상황이 발생하면 해당처리 루틴을 실행해 처리
    - 폴링은 주기적으로 마이크로프로세서가 상태를 파악하기 위해 장치의 레지스터를 읽어야 한다.(장치의 상태를 읽는데 마이크로프로세서의 자원이 낭비)
    - 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트서비스 루틴을 수행(하드웨어에 비해 속도 느림)
  - 인터럽트 방식
    - 상대가 마이크로프로세서에게 일을 처리해 달라고 요청하는 수단
      - Daisy Chain
      - 병렬 우선순위 부여

- 인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만 폴링에 비해 신속하게 대응하는 것이 가능하다
- 즉 인터럽트는 발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법이다.
