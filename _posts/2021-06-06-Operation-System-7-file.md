---
title: Operation System 6 file
author: Jiny
date: 2021-06-06 16:30:00 +0800
categories: [CS, OS]
tags: [cs, os, file]
toc: false
---
 
# Operation System 6(파일 시스템)
___

## 💿 **파일**

> 운영체제의 저장장치의 물리적 특성을 추상화한 논리적 저장 단위

파일은 운영체제에 의해 물리 장치들로 맵핑되기도 하며, 

일반적으로 비휘발적 특성을 지니기 때문에, 전원이 끊어진 상황에서도 정보들을 영구히 보존할 수 있다

- 프로그램 : 소스 프로그램, 목적 프로그램으로 나누어 진다.
- 자료 : 숫자,문자,이진수, 자유 형식이거나 정해진 형식 등, 저장할 수 있는 모든 것이 자료가 될 수 있다.

### **파일 속성**

- 이름 : 사람이 읽을 수 있는 형태로 유지되는 유일한 정보
- 식별자 : 파일 시스템 내에서 파일을 식별하는 고유의 번호 PK
- 타입 : 여러 타입의 파일을 제공하는 시스템을 위해 필요
- 위치 : 장치 내에서 파일의 위치를 가리키는 포인터
- 크기 : 파일의 현재 크기
- 보호 : 접근 제어 정보
- 시간, 날짜, 사용자 식별 : 생성, 최근 변경, 최근 사용 등에 대한 정보
  모든 파일에 대한 정보는 보조 저장장치에 상주하는 디렉토리 구조 내에 유지된다. 
  - 파일과 디렉터리 모두 비휘발적 성질을 가져야 하므로, 저장 장치 상에 저장되고, 필요할 때 조금씩 메모리로 가져와야 한다.

### **파일 연산**

- 파일 생성 : 사용할 수 있는 공간을 찾고 파일을 할당한다, 또한 파일이 디렉터리에 만들어져야 한다.
- 파일 쓰기 : 파일 이름과 기록될 정보를 명시하는 시스템 콜을 호출한다.    
  - 시스템은 파일 내의 다음 쓰기가 일어날 위치를 가리키는 쓰기 포인터를 유지하고 있어야 한다. 
  - 쓰기 포인터는 쓰기가 일어날 때마다 갱신된다.
- 파일 읽기 : 파일 이름과 피일이 읽혀 들어갈 블록의 위치를 명시하는 시스템 콜을 호출한다. 
  - 다음 읽기가 일어날 파일 안의 위치를 기록하는 읽기 포인터를 유지해야 한다.
  - 프로세스는 일반적으로 파일 읽기 나 파일 쓰기 중 한 가지를 하고 있기 때문에, 대부분의 시스템은 한 개의 현재 파일 위치 포인터 를 가진다. 읽기,쓰기 연산 모두 이 포인터를 이용하여 공간을 절약하고, 복잡성을 감소시킨다.
- 파일 안에서의 위치 재설정 : 디렉터리에서 적합한 항목을 탐색하고, 현재 파일 위치를 주어진 값으로 설정한다.
- 파일 삭제 : 지명된 파일을 디렉터리에서 찾는다, 발견하면 파일이 차지하는 공간을 방출하고 디렉터리 항목을 삭제한다.
- 파일 절단 : 파일의 내용을 지우고, 속성만을 남긴다.
위에 있는 6개의 연산은 파일 조작에 필요한 최소한의 연산이다. 
  - 새로운 정보를 추가하는 첨가(appending) 나 재명명(renaming) 등이 더 있다.
  - 운영체제는 모든 열린 파일에 대한 정보를 갖는 열린 파일 테이블(open file table) 을 유지한다.
  - 시스템 콜 open()은 전형적으로 열린 파일 테이블의 항목에 대한 포인터를 리턴한다.

### **다중 프로세스 환경**

> 다중 프로세스 환경에서는 open()과 close() 연산의 구현은 더 복잡한데, 보통 운영체제는 프로세스별 테이블과 범 시스템 테이블을 사용한다.

- 프로세스 별 테이블: 파일 포인터, 접근 권한
- 범 시스템 테이블: 프로세스에 독립적인 정보들 : 디스크 상의 파일 위치, 접근 날짜, 크기

### **오픈 파일 테이블**

파일이 하나의 프로세스에 의해 열려 있다. 

이때 다른 프로세스가 open()을 호출한 경우 오픈 파일 테이블에 범 시스템 테이블 에 있는 정보를 가리키는 새로운 포인터가 생긴다.

일반적으로 오픈 파일 테이블은 파일을 연 프로세스 수를 가리키는 오픈 계수 (open count)를 각 파일에 연관지어 둔다. close() 콜은 이 오픈 계수를 감소시키고 계수가 0이 되면 해당 정보를 테이블에서 제거한다.

___

## 💿 **파일 시스템**

> 컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록 유지 및 관리하는 방법

### **특징**

- 커널 영역에서 동작
- 파일 CRUD 기능을 원할히 수행하는 목적
- 계층적 디렉터리 구조를 가짐
- 디스크 파티션 별로 하나씩 있음

### **역할**

- 파일 관리
- 보조 저장소 관리
- 파일 무결성 매커니즘
- 접근 방법 제공

### **개발 목적**

- 하드디스크와 메인 메모리 속도차를 줄이기 위함
- 파일 관리
- 하드디스크 용량의 효율적 이용

### **구조**

- 메타 영역: 데이터 영역에 기록된 파일 이름, 위치, 크기, 시간정보, 삭제유무 등의 파일 메타 정보
- 데이터 영역: 파일의 데이터

___

## 💿 **접근 방법**

### **순차 접근**

> 가장 간단한 방법으로 대부분 연산은 read 와 write

![image](https://camo.githubusercontent.com/3d98ce630359f31bcff0c3741e2a230ef161c4d6239803e722ca054a7a981751/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e312e706e67)

현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read 와 write를 진행 뒤로 돌아갈 땐 지정한 offset 만큼 되감기를 해야 한다.(테이프 모델 기반)

### **직접 접근**

> 특별한 순서없이, 빠르게 레코드를 read, write 가능

![image](https://camo.githubusercontent.com/7561e732c8eec57fe126bce5f3d2f8e5dfd8cd7d2210eb275d249699db15f0d6/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e322e706e67)

현재 위치를 가리키는 cp 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현 가능

무작위 파일 블럭에 대한 임의 접근을 허용한다. 따라서 순서의 제약이 없음

대규모 정보를 접근할 때 유요하기 때문에 데이터베이스 에서 활용됨

### **기타 접근**

> 파일에서 레코드를 찾기 위해서 이 색인 부터 찾아 그에 대응하는 포인터를 얻는다 그런 다음 그 포인터를 사용하여 파일에 직접 접근하여 원하는 레코드를 얻는다.


![image](https://camo.githubusercontent.com/47fc4842a54b5e76f61a6a6dd6e3403a223f3d51c22ad2dad9f08a68e3cfd2ac/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e332e706e67)

___

## 💿 **디렉터리와 디스크 구조**

### **1단계 디렉터리**

> 파일들은 서로 유일한 이름을 가짐. 서로 다른 사용자라도 같은 이름 사용 불가

![image](https://camo.githubusercontent.com/64e17df3257a6613a4dd3785c29992e5a11b5d3ad2921335bf79c3a7c69f959e/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e352e706e67)

### **2단계 디렉터리**

> 사용자 별 개별적인 디렉터리 만들어줌

- UFD : 자신만의 사용자 파일 디렉터리
- MFD : 사용자의 이름과 계정번호로 색인되어 있는 디렉터리

![image](https://camo.githubusercontent.com/481d06b7e5e499c43e916ea8412a130be2f6bbb5cad332d6f6d3e327a0acf0d1/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e362e706e67)

### **트리구조 디렉터리**

> 2단계 에서 확장된 다단계 트리 구조

한 비트를 활용하여 일반 파일인지 디렉터리 파일인지 구분

![image](https://camo.githubusercontent.com/84f459c97d762e85f623e5198699e8e2f6353eb4b97489390fac3f21bc012555/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e372e706e67)

### **그래프 구조 디렉터리**

> 순환이 발생하지 않도록 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나 가비지 컬렉션을 이용한 전체 파일 시스템을 순회하고 접근 가능 한 모든 것을 표시

![image](https://camo.githubusercontent.com/1bcf4d313ab3dd04f9c747a86e12943c1fe978758f85f6a8069cb018ff4f5198/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e392e706e67)

___

## 💿 **파일 시스템 마운팅**

![image](https://noep.github.io/2016/02/23/10th-filesystem/10.10.png)
![image](https://noep.github.io/2016/02/23/10th-filesystem/10.11.png)