---
title: Baekjoon-17831
author: Jiny
date: 2021-03-21 15:30:00 +0800
categories: [Java, Algo]
tags: [baekjoon, dp]
toc: false
---

# **가장 긴 증가하는 부분 수열**
---
## **코드**
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    static List<Integer>[] map;
    static int[] parent;
    static int[] power;
    static int[] mentor;
    static int n;

    static int[][] dp;

    static int dfs( int cur, int isMentor) {
        if(dp[cur][isMentor] != -1) {
            return dp[cur][isMentor];
        }

        int result = 0;
        if(isMentor == 1) {
            int sum = 0;
            for (int child: map[cur]){
                int temp1 = dfs(child, 0);
                int temp2 = dfs(child, 1);
                if (temp1 > temp2){
                    sum += temp1;
                    mentor[child] = 0;
                }
                else {
                    sum += temp2;
                    mentor[child] = 1;
                }
            }
            
            /*
            일단 자식 노드들의 metor 일때와 아닐 때중 최대를 더한다.
            */    

            for (int child: map[cur]){
                int temp = sum - dfs(child, mentor[child]);
                temp += (dfs(child, 0) + power[cur] * power[child]);
                result = Math.max(result, temp);
            }

            /*
            합에서 하나씩 최대가 될때의 서브트리 시너지 합을 뺴고 만약 부모가
            멘토로 선정 되었다면 자식노드는 멘토가 될 수 없으므로 현재 시너지에서 
            멘토가 되지 않을때의 서브트리 시너지 합을 더한다.
            */

        } else {
            for(int child : map[cur]) {
                result += Math.max(dfs(child, 0), dfs(child, 1));
            }
        }

        return dp[cur][isMentor] = result;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));


        n = Integer.parseInt(br.readLine());
        parent = new int[n+1];
        power = new int[n+1];
        mentor = new int[n+1];
        dp = new int[n+1][2];

        map = new List[n+1];
        for (int i = 0; i < map.length; i++) {
            map[i] = new ArrayList<>();

        }

        String[] str = br.readLine().split(" ");
        for(int i=2; i<=n; i++) {
            parent[i] = Integer.parseInt(str[i-2]);
            map[parent[i]].add(i);
        }

        str = br.readLine().split(" ");
        for(int i=1; i<=n; i++) {
            power[i] = Integer.parseInt(str[i-1]);
            dp[i][0] = -1; dp[i][1] = -1;
        }

        System.out.println(Math.max(dfs(1, 0), dfs(1, 1)));
    }
}
```   
<br/>


## **문제**

㈜승범이네는 사장 승범이를 포함한 N명의 직원이 모두 판매원인 다단계 회사이다. 사장 승범이를 제외한 모든 판매원에게는 사수가 한 명씩 배정된다. 만약 판매원 A가 B의 사수라면, B를 A의 부사수라고 부른다.


작년에 창설된 ㈜승범이네는 큰 수익률을 기록하고 대기업으로 거듭났다. ㈜승범이네의 더 큰 성장을 위해 멘토링 제도를 도입하려고 한다. 승범이는 사수와 부사수 관계에 있는 두 판매원을 각각 서로의 멘토와 멘티로 만들 수 있으며, 이 경우 두 판매원이 멘토링 관계에 있다고 한다. 한 판매원은 최대 1개의 멘토링 관계에만 속할 수 있다. 즉, 한 판매원이 여러 명의 멘토가 되거나, 여러 명의 멘티가 되거나, 멘토인 동시에 멘티가 될 수는 없다. 물론 멘토링 관계에 속하지 않는 직원이 있을 수도 있다.


이렇게 만들어진 멘토링 관계에서는 시너지 효과가 발생한다. 승범이는 모든 판매원의 실력을 수치화시켰으며, 한 멘토링 관계에서 발생하는 시너지는 멘토와 멘티의 실력의 곱과 같다는 것을 발견했다. 승범이는 적절하게 멘토링 관계를 만들어, 모든 멘토링 관계에서 발생하는 시너지의 합을 최대로 만들려고 한다.

![image](https://upload.acmicpc.net/3dd33770-33c1-424f-8547-a227b1654868/-/preview/)

위 그림은 ㈜승범이네의 회사 구조와 멘토링 관계를 나타낸 예시이다. 각 원은 한 명의 판매원을 의미하며, 원 안에 쓰인 숫자는 그 판매원의 실력이다. 화살표는 사수-부사수 관계를 나타낸다. 이 경우 가능한 시너지의 최대 합은 5×7 + 4×3 + 3×3 + 4×5 + 3×1 = 79이다.

## **입력**

첫 번째 줄에 판매원들의 수 N(2 ≤ N ≤ 200,000)이 주어진다. 판매원들은 1번, 2번, …, N번으로 번호가 매겨지며, 승범이는 항상 1번이다.

두 번째 줄에 2번 판매원부터 N번 판매원의 사수가 순서대로 공백으로 구분되어 주어진다. 

세 번째 줄에 i번 판매원의 실력을 나타내는 정수 A1, A2, …, AN (0 ≤ Ai ≤ 100)이 순서대로 공백으로 구분되어 주어진다.

## **출력**

첫 번째 줄에 모든 멘토링 관계에서 발생하는 시너지의 합의 최댓값을 출력한다. 만약 멘토링 관계가 하나도 성립될 수 없을 경우, 0을 출력한다.

## **예시**

- 입력

<pre>
    12
    1 1 1 2 2 6 7 3 4 10 4
    5 7 3 4 4 2 4 3 3 3 1 5
</pre>

- 출력

<pre>
	79
</pre>

## **기본 컨셉**

> 트리 DP

- dp[i][j]: i번쨰 노드를 root 노드로 하는 서브 트리에서 i번째 노드를 맨토로 정하느냐 그렇지 않느냐에 따른 시너지 합의 최대값(한다=1, 안한다=0)
- 노드 A가 멘토로 선택되지 않은 경우
  - 이는 노드 A가 멘티이거나 아무 역할로 정해지지 않은 경우를 의미한다. 노드 A를 기준으로 노드 A의 각 자식들은 서로 독립적이므로 각 자식들의 시너지 합의 최댓값이 각각 크면 클수록 이득이다. (트리 A의 시너지 합의 최댓값이 보장된다.)
- 노드 A가 멘토로 선택되는 경우 (j == 1)
    - 노드 A의 자식 중에서 하나의 자식 노드는 무조건 멘티로 정해져야 한다. 앞서 말한 바처럼 같은 부모 노드를 갖는 노드들은 시너지 최댓값에 있어서 서로 독립적이므로 한 자식 노드가 멘티로 선택되어도 나머지 자식 노드는 영향을 받지 않는다.
- mentor 배열: index의 노드의 서브 트리의 시너지 합이 최대일때 이 노드가 metor인지 아닌지

