---
title: Operation System 4 memory
author: Jiny
date: 2021-06-06 12:30:00 +0800
categories: [CS, OS]
tags: [cs, os, memory]
toc: false
---
 
# Operation System 4(메모리)
___

## 💿 **메모리**

> 메모리는 주소와 데이터로 구성

CPU가 원하는 데이터의 주소를 메모리에 보내주게 되면 CPU에게 해당하는 데이터를 보내준다. 또한 CPU에서 계산된 결과를 메모리의 특정 주소를 담아 명령을 보내면 메모리에 해당 주소에 데이터를 저장한다.

프로그램을 개발할 때는 여러 가지의 파일 형태로 개발을 하는데 소스 파일은 고수준언어 혹은 어셈블리로 개발된 파일을 말한다.

1. 소스파일은 컴파일러와 어셈블러에 의해 목적 파일로 전환된다.
   - 목적파일은 소스 파일에 대한 컴파일 또는 어셈블 결과를 나타내는 파일로 기계어로 나타내 진다
2. 목적 파일을 링크가 실행파일로 바꾼다,
   - 링크는 하드디스크에 들어가 있는 다양한 내장 함수(Library)들을 실행하기 위해 연결해 주는 과정
   - 만들어진 실행 파일을 메모리에 적재하는 과정을 하는 것이 로더 
3. 실행파일은 로더에 의해 적재되어 실행이 가능해 진다.

![image](https://t1.daumcdn.net/cfile/tistory/23535E465902EABB12)

하나의 프로그램이 실행되기 위해서는 코드와 데이터, 스택 메모리를 가지고 있어야 한다.

- 코드: 앞서 작성한 파일들
- 데이터: 프로그램이 실행될 때 넣어 주어야 할 값
  - 예를들어 큰 수를 나타내는 프로그램이라면 두 수를 입력하는 값이 데이터
- 스택: 함수를 호출 했을 때 돌아오는 주소와 지역변수를 저장하는 공간

### **MMU**

> 운영체재는 실행파일이 로더에 의해 메모리에 올려 질때 어디 부분에 올릴지를 결정한다.

- 다중 프로그램 환경에서 메모리에 프로그램을 넣어주고 다시 하드디스크로 보내주고 하는 과정을 모두 OS에서 담당
- 사실 고수준 언어를 작성할 때에는 주소를 사용하여 작성하지 않지만 목적 파일로 바뀌어 실행파일을 사용하면 주소의 값을 통해 코드를 이동하고 작동
- 따라서 메모리에 적재할때 적절한 메모리 위치에 프로그램을 넣지 않으면 문제가 발생할 수 있는데 이러한 문제를 해결하는 것이 MMU

MMU에는 재배치 레지스터가 존재하는데 이는 코드가 원하는 주소를 만들어주는 역할을 한다.

![image](https://t1.daumcdn.net/cfile/tistory/267E56465902EABA1F)

___

## 💿 **메모리 낭비 방지**

MMU는 프로그램이 동작할 때 필요한 데이터나 동작들을 메모리의 특정 주소 위치로부터 가지고 와야 하는데 이는 프로그램이 만들어질 때 마다 코드화 되어있다. 따라서 항상 같은 위치의 메모리 주소로 부터 데이터를 불러오게 된다.

하지만 메모리에 프로그램을 적재할 때 항상 같은 위치에 프로그램을 올릴 수는 없다. 이는 메모리 공간에서 빈공간을 찾아 프로그램을 올리기 때문에 **빈 공간 위치에 따라 주소가 달라지기 때문이다.**

이를 맞추어 조절해 주는 것이 MMU의 **재배치 레지스터**이다.

CPU에서 원하는 데이터 위치와 메모리상에 프로그램의 위치를 맞게 맞추어 준다. 여기서 CPU에서 MMU로 보내는 주소를 논리 주소라고 하고 MMU에서 메모리로 보내는 주소는 물리 주소라 한다.

### **동적 적재**

> 프로그램에 반드시 필요한 루틴/데이터만 적재하는 것

### **동적 연결**

> 여러 프로그램에 공통 사용되는 라이브러리를 관리하는 방법

- prinf()와 같은 C언어에서 사용하는 공통 라이브러리가 존재
- 라이브러리 루틴 연결을 실행 시까지 미루고 오직 하나의 라이브러리 루틴만 메모리에 적재해서 이 루틴과 연결을 하도록 하는 방법을 통해서 적용

### **swapping**

> 메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스를 관리하는 역할

- swap out
  - 메모리 활용도를 높이기 위해 Swapping을 이용하면 현재 사용되지 않는 프로세스를 Backing store로 몰아낸다.(Backing Store는 하드디스크의 일부분이다.)
- swap in
  - 필요한 부분이 생기면 그 부분에 대해 메모리로 적재해서 올려주는 것

MMU의 재배치 레지스터로 적재 위치는 메모리의 빈공간 어디에도 적재가 가능하다.

하지만 프로세스가 너무 크면 Backing store 입출력에 따른 부담이 크다

![image](https://t1.daumcdn.net/cfile/tistory/26647A47590433AB2D)

__

## 💿 **연속 메모리 할당**

1. 처음에 부팅 직후에는 운영체제만 적재되어 있으므로 운영체제를 제외한 공간이 모두 비어 있게 된다. 그래서 big single hole이 생기게 된다.
2. 프로세스가 생성되고 종료되는 작업을 반복하며 컴퓨터가 동작하게 된다. 이 때는 프로세스들은 여러 위치의 메모리에 적재되기 때문에 scattered holes가 생성되게 된다.

프로세스가 순서대로 쌓이더라도 작업이 끝나는 순서는 정해져 있지 않고 다시 들어오는 프로세스와도 메모리 공간 차지 사이즈가 다르기 때문에 메모리의 빈 공간이 중간 중간에 계속 생김

![image](https://t1.daumcdn.net/cfile/tistory/2216D94E5908180A15)

이러한 hole들이 불연속하게 흩어져 있게 되어 메모리 단편화 현상이 발행

메모리의 빈공간은 많은데 사이즈가작은 빈 공간이 많아 다른 프로세스를 적재할 수 없는 외부 단편화 발생

- 외부단편화 : 구멍을 합치면 사용가능 한데, 구멍들의 크기가 작아 사용하기 곤란한 상황
- 내부단편화 : 메모리의 영역을 사용하고 남은 공간



외부 단편화를 없애는 방식으로 **연속 메모리 할당 방식**을 사용한다. 연속 메모리 할당 방식에도 3가지의 방법이 존재한다. 그리고 Compaction 까지도 사용하지만 문제가 생기기 때문에 Paging이 나오게 된다.

- 최초 적합(First-fit): 메모리를 순차적으로 탐색하여 제일 먼저 발견한 적절하게 들어갈 수 있는 곳을 찾아 프로세스를 적재하는 방법이다.
- 최적 적합(Best-fit): 메모리를 탐색하여 메모리 공간 중에서 제일 적절하게 들어갈 수 있는 곳을 찾아 프로세스를 적재하는 방법이다.
- 최악 적합(Worst-fit): 메모리에 넣는데 크기와 제일 안 맞는 공간(프로세스보다 큰 메모리 공간 중에서)에 프로세스를 넣는 방식이다.
- Compaction: hole 들을 한 곳으로 모으겠다는 방식 
  - 하지만 메모리를 계산해서 움직여야 하기 때문에 부담이 크다

