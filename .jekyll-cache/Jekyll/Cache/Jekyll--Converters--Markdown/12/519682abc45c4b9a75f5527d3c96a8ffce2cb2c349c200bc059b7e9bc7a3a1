I"95<h1 id="generic">Generic</h1>
<hr />

<h2 id="-generic">🔘 Generic</h2>

<blockquote>
  <p>Data Type을 일반화 하는것을 의미</p>
</blockquote>

<ul>
  <li>Classs 나 Method에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법
    <ul>
      <li>Class나 메서드 내부에서 사용되는 객체의 타입의 안정성을 높일 수 있다.</li>
      <li>반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.</li>
    </ul>
  </li>
  <li>Object 타입으로 사용시 다시 타입 변환을 해줘야 하는 번거로움이 있을 수 있다.</li>
</ul>

<h3 id="장점">장점</h3>

<ul>
  <li>잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있기 때문</li>
  <li>컴파일러는 제네릭 코드에 대해 강한 타입 체크를 한다.</li>
  <li>실행 시 타입 에러가 나는 것보다 컴파일 시에 미리 타입을 강하게 체크해서 에러를 사전에 방지</li>
  <li>타입 변환을 할 필요가 없어 프로그램 성능이 향상</li>
</ul>

<h3 id="사용">사용</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> --><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">GenericSample</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="no">T</span> <span class="n">element</span><span class="o">;</span>
	<span class="kt">void</span> <span class="nf">setElement</span><span class="o">(</span><span class="no">T</span> <span class="n">element</span><span class="o">){</span>
		<span class="k">this</span><span class="o">.</span><span class="na">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">;</span>
		<span class="no">T</span> <span class="nf">getElement</span><span class="o">()</span> <span class="o">{</span>
			<span class="k">return</span> <span class="n">element</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="타입-변수">타입 변수</h3>

<ul>
  <li>이름에 제한 없음</li>
  <li>여러개의 타입 변수는 ,로 구분</li>
  <li>Class에서 뿐만 아니라 Method의 매개변수나 반환값으로도 사용 가능</li>
  <li>임의의 참조형 타입을 의미</li>
  <li>현존하는 클래스를 사용해도 되고 존재하지 않는 것을 사용해도 됨</li>
</ul>

<h3 id="이름">이름</h3>

<ul>
  <li>E: 요소</li>
  <li>K: 키</li>
  <li>N: 숫자</li>
  <li>T: 타입</li>
  <li>V: 값</li>
  <li>S,U,V: 두번쨰, 세번째, 네번째</li>
</ul>

<hr />

<h2 id="-bounded-type-parameter">🔘 Bounded type parameter</h2>

<blockquote>
  <p>특정 타입의 서브 타입으로 제한</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> --><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoundTypeSample</span><span class="o">&lt;</span><span class="no">T</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{}</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">BoundTypeSample</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">bound</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoundTypeSample</span><span class="o">&lt;&gt;();</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>Number의 서브 타입만 허용</li>
</ul>

<h2 id="-wildcard">🔘 WildCard</h2>

<blockquote>
  <p>제네렉으로 구현된 Method의 경우 선언된 타입으로만 매개변수를 입력해야 한다. 이를 상속받은 클래스 혹은 부모 Class에서 사용 불가하기 하고 어떤 타입이 와도 상관없는 경우에 대응하기 좋지 않다.</p>
</blockquote>

<h3 id="unbounded-wildcard">Unbounded WildCard</h3>

<ul>
  <li>List&lt;?&gt; 와 같은 형태로 물음표만 가지고 정의
    <ul>
      <li>내부적으로 Object로 정의되어서 사용되고 모든 타입의 인자를 받을 수 있다.</li>
    </ul>
  </li>
  <li>Object 클래스에서 제공되는 기능을 사용하여 구현할 수 있는 Method를 작성할 경우</li>
  <li>타입 파라미터에 의존적이지 않은 Class의 Method를 사용하는 경우</li>
</ul>

<h3 id="upper-bounded-wildcard">Upper Bounded WildCard</h3>

<ul>
  <li>List&lt;? extends Foo&gt; 와 같은 형태로 특정클래스의 서브 클래스만 인자로 받음
    <ul>
      <li>Foo 클래스에 정의된 기능만 사용이 가능하다.</li>
    </ul>
  </li>
</ul>

<h3 id="lost-bounded-wildcard">Lost Bounded WildCard</h3>

<ul>
  <li>List&lt;? super Foo&gt; 와 같은 형태로 특정 클래스의 상위 클래스만 인자로 받음</li>
</ul>

<hr />

<h2 id="-매개변수화-타입parameterized-type">🔘 매개변수화 타입(Parameterized Type)</h2>

<ul>
  <li>하나 이상의 타입 매개변수를 선언하고 있는 Class 나 Interface를 제네릭 클래스 또는 제네릭 인터페이스라고 하고 이를 제네릭 타입이라 한다. 각 제네릭 타입에서는 매개변수화 타입들을 정의한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>&lt;&gt;안의 String은 실 타입 매개변수라고 하고 List 인터페이스에 선언되어있는 List의 E를 형식 타입 매개변수라고 한다.
    <ul>
      <li>제네릭은 타입소거자에 의해 자신의 타입 요소 정보를 삭제한다.</li>
      <li>ArrayList를 생성할 때 어떠한 타입 정보도 들고 있지 않게 된다.</li>
      <li>즉 new ArrayList() 와 같음</li>
    </ul>
  </li>
  <li>컴파일러는 컴파일 단계에서 List 컬렉션에 String 인스턴스만 저장되어야 한다는 것을 알게되었고 또 그것을 보장해주기 때문에 ArrayList list로 변경하여도 런타임에 동일한 동작을 보장</li>
  <li>타입 소거자에의해 컴파일 타임에 타입 정보가 사라지는 것: 비 구체화
    <ul>
      <li>E, List 와 같은 런타임에 구체화하지 않는 타입들을 비 구체화(non reifiable type)타입이라고 한다.</li>
      <li>반대로 primitive, non-generic types, raw types 또는 List&lt;?&gt; Map 과 같은 Unbounded WildCard Type은 런타임에 구체화 하여 구체화(reifiable type)이라고 한다.</li>
    </ul>
  </li>
</ul>

<h3 id="제네릭-선엔에-사용하는-타입의-범위도-지정-가능">제네릭 선엔에 사용하는 타입의 범위도 지정 가능</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> --><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarWildCardSample</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">CarWildCardSample</span> <span class="n">sample</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CardWukdcardSample</span><span class="o">();</span>
		<span class="n">sample</span><span class="o">.</span><span class="na">callBoundedWildcardMethod</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">callBoundedWildcardMethod</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">WildcardGeneric</span><span class="o">&lt;</span><span class="nc">Car</span><span class="o">&gt;</span> <span class="n">wildcard</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WildcardGeneric</span><span class="o">&lt;</span><span class="nc">Car</span><span class="o">&gt;();</span>
		<span class="n">boundedWildCardMethod</span><span class="o">(</span><span class="n">wildcard</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">boundedWildCardMethod</span><span class="o">(</span><span class="nc">WildCardGeneric</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Car</span><span class="o">&gt;</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Car</span> <span class="n">value</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">getWildCard</span><span class="o">();</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WildcardGeneric</span><span class="o">&lt;</span><span class="no">W</span><span class="o">&gt;</span> <span class="o">{</span>
	<span class="no">W</span> <span class="n">wildcard</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> --><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Car</span> <span class="o">{}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Bus</span> <span class="kd">extends</span> <span class="nc">Car</span> <span class="o">{}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<hr />

<h2 id="-제네릭-메서드">🔘 제네릭 메서드</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> --><td class="rouge-code"><pre>- 접근지시자 &lt;타입파라미더, ...&gt; 리던타입 메서드명(매개변수, ...) { ... }의 형식
- public &lt;T&gt; Box&lt;T&gt; boxing(T t) { ... };
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="호출">호출</h3>

<ol>
  <li>Box<Integer> box = <Integer> boxing(100);
</Integer></Integer>    <ul>
      <li>명시적으로 구체적 타입 지정</li>
    </ul>
  </li>
  <li>Box<Integer> box = boxing(1000);
</Integer>    <ul>
      <li>매개값을 보고 구체적 타입을 추정</li>
    </ul>
  </li>
</ol>

<hr />

<h2 id="-erasure">🔘 Erasure</h2>

<blockquote>
  <p>원소 타입을 컴파일 타임에서만 검사하고 런타임에는 해당 타입 정보를 알수가 없다.</p>
</blockquote>

<ul>
  <li>즉 컴파일 상태에만 제약 조건을 적용하고 런타임에는 타입에 대한 정보를 소거</li>
</ul>

<h3 id="과정">과정</h3>

<ul>
  <li>제네릭 타입에서는 해당 타입 파라미터(T)나 Object(unbounded)로 변경</li>
  <li>타입 안정성 보존을 위해 필요시 type casting 삽입</li>
  <li>확장된 제네릭 타입에서 다형성 보존하기 위해 bridge method 생성</li>
</ul>

<h3 id="유형">유형</h3>

<h3 id="class-type-erasure">Class Type Erasure</h3>

<p>클래스 수준에서 컴파일러는 클래스의 Type Parameter를 버리고 첫번째 바인딩으로 대체하거나 Type Parameter가 바인딩(extends 등으로) 되지 않은 경우 Object로 변환</p>

<h3 id="method-type-erasure">Method Type Erasure</h3>

<p>method-level type erasure가 바인딩되지 않은 경우 부모 형식 Object로 변환되거나 바인딩 될 때 첫번쨰 바인딩 된 클래스로 변환</p>
:ET