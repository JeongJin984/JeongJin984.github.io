I"a<h1 id="operation-system-4메모리">Operation System 4(메모리)</h1>
<hr />

<h2 id="-메모리">💿 <strong>메모리</strong></h2>

<blockquote>
  <p>메모리는 주소와 데이터로 구성</p>
</blockquote>

<p>CPU가 원하는 데이터의 주소를 메모리에 보내주게 되면 CPU에게 해당하는 데이터를 보내준다. 또한 CPU에서 계산된 결과를 메모리의 특정 주소를 담아 명령을 보내면 메모리에 해당 주소에 데이터를 저장한다.</p>

<p>프로그램을 개발할 때는 여러 가지의 파일 형태로 개발을 하는데 소스 파일은 고수준언어 혹은 어셈블리로 개발된 파일을 말한다.</p>

<ol>
  <li>소스파일은 컴파일러와 어셈블러에 의해 목적 파일로 전환된다.
    <ul>
      <li>목적파일은 소스 파일에 대한 컴파일 또는 어셈블 결과를 나타내는 파일로 기계어로 나타내 진다</li>
    </ul>
  </li>
  <li>목적 파일을 링크가 실행파일로 바꾼다,
    <ul>
      <li>링크는 하드디스크에 들어가 있는 다양한 내장 함수(Library)들을 실행하기 위해 연결해 주는 과정</li>
      <li>만들어진 실행 파일을 메모리에 적재하는 과정을 하는 것이 로더</li>
    </ul>
  </li>
  <li>실행파일은 로더에 의해 적재되어 실행이 가능해 진다.</li>
</ol>

<p><img src="https://t1.daumcdn.net/cfile/tistory/23535E465902EABB12" alt="image" /></p>

<p>하나의 프로그램이 실행되기 위해서는 코드와 데이터, 스택 메모리를 가지고 있어야 한다.</p>

<ul>
  <li>코드: 앞서 작성한 파일들</li>
  <li>데이터: 프로그램이 실행될 때 넣어 주어야 할 값
    <ul>
      <li>예를들어 큰 수를 나타내는 프로그램이라면 두 수를 입력하는 값이 데이터</li>
    </ul>
  </li>
  <li>스택: 함수를 호출 했을 때 돌아오는 주소와 지역변수를 저장하는 공간</li>
</ul>

<h3 id="mmu"><strong>MMU</strong></h3>

<blockquote>
  <p>운영체재는 실행파일이 로더에 의해 메모리에 올려 질때 어디 부분에 올릴지를 결정한다.</p>
</blockquote>

<ul>
  <li>다중 프로그램 환경에서 메모리에 프로그램을 넣어주고 다시 하드디스크로 보내주고 하는 과정을 모두 OS에서 담당</li>
  <li>사실 고수준 언어를 작성할 때에는 주소를 사용하여 작성하지 않지만 목적 파일로 바뀌어 실행파일을 사용하면 주소의 값을 통해 코드를 이동하고 작동</li>
  <li>따라서 메모리에 적재할때 적절한 메모리 위치에 프로그램을 넣지 않으면 문제가 발생할 수 있는데 이러한 문제를 해결하는 것이 MMU</li>
</ul>

<p>MMU에는 재배치 레지스터가 존재하는데 이는 코드가 원하는 주소를 만들어주는 역할을 한다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/267E56465902EABA1F" alt="image" /></p>

<hr />

<h2 id="-메모리-낭비-방지">💿 <strong>메모리 낭비 방지</strong></h2>

<p>MMU는 프로그램이 동작할 때 필요한 데이터나 동작들을 메모리의 특정 주소 위치로부터 가지고 와야 하는데 이는 프로그램이 만들어질 때 마다 코드화 되어있다. 따라서 항상 같은 위치의 메모리 주소로 부터 데이터를 불러오게 된다.</p>

<p>하지만 메모리에 프로그램을 적재할 때 항상 같은 위치에 프로그램을 올릴 수는 없다. 이는 메모리 공간에서 빈공간을 찾아 프로그램을 올리기 때문에 <strong>빈 공간 위치에 따라 주소가 달라지기 때문이다.</strong></p>

<p>이를 맞추어 조절해 주는 것이 MMU의 <strong>재배치 레지스터</strong>이다.</p>

<p>CPU에서 원하는 데이터 위치와 메모리상에 프로그램의 위치를 맞게 맞추어 준다. 여기서 CPU에서 MMU로 보내는 주소를 논리 주소라고 하고 MMU에서 메모리로 보내는 주소는 물리 주소라 한다.</p>

<h3 id="동적-적재"><strong>동적 적재</strong></h3>

<blockquote>
  <p>프로그램에 반드시 필요한 루틴/데이터만 적재하는 것</p>
</blockquote>

<h3 id="동적-연결"><strong>동적 연결</strong></h3>

<blockquote>
  <p>여러 프로그램에 공통 사용되는 라이브러리를 관리하는 방법</p>
</blockquote>

<ul>
  <li>prinf()와 같은 C언어에서 사용하는 공통 라이브러리가 존재</li>
  <li>라이브러리 루틴 연결을 실행 시까지 미루고 오직 하나의 라이브러리 루틴만 메모리에 적재해서 이 루틴과 연결을 하도록 하는 방법을 통해서 적용</li>
</ul>

<h3 id="swapping"><strong>swapping</strong></h3>

<blockquote>
  <p>메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스를 관리하는 역할</p>
</blockquote>

<ul>
  <li>swap out
    <ul>
      <li>메모리 활용도를 높이기 위해 Swapping을 이용하면 현재 사용되지 않는 프로세스를 Backing store로 몰아낸다.(Backing Store는 하드디스크의 일부분이다.)</li>
    </ul>
  </li>
  <li>swap in
    <ul>
      <li>필요한 부분이 생기면 그 부분에 대해 메모리로 적재해서 올려주는 것</li>
    </ul>
  </li>
</ul>

<p>MMU의 재배치 레지스터로 적재 위치는 메모리의 빈공간 어디에도 적재가 가능하다.</p>

<p>하지만 프로세스가 너무 크면 Backing store 입출력에 따른 부담이 크다</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/26647A47590433AB2D" alt="image" /></p>

<p>__</p>

<h2 id="-연속-메모리-할당">💿 <strong>연속 메모리 할당</strong></h2>

<ol>
  <li>처음에 부팅 직후에는 운영체제만 적재되어 있으므로 운영체제를 제외한 공간이 모두 비어 있게 된다. 그래서 big single hole이 생기게 된다.</li>
  <li>프로세스가 생성되고 종료되는 작업을 반복하며 컴퓨터가 동작하게 된다. 이 때는 프로세스들은 여러 위치의 메모리에 적재되기 때문에 scattered holes가 생성되게 된다.</li>
</ol>

<p>프로세스가 순서대로 쌓이더라도 작업이 끝나는 순서는 정해져 있지 않고 다시 들어오는 프로세스와도 메모리 공간 차지 사이즈가 다르기 때문에 메모리의 빈 공간이 중간 중간에 계속 생김</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/2216D94E5908180A15" alt="image" /></p>

<p>이러한 hole들이 불연속하게 흩어져 있게 되어 메모리 단편화 현상이 발행</p>

<p>메모리의 빈공간은 많은데 사이즈가작은 빈 공간이 많아 다른 프로세스를 적재할 수 없는 외부 단편화 발생</p>

<ul>
  <li>외부단편화 : 구멍을 합치면 사용가능 한데, 구멍들의 크기가 작아 사용하기 곤란한 상황</li>
  <li>내부단편화 : 메모리의 영역을 사용하고 남은 공간</li>
</ul>

<p>외부 단편화를 없애는 방식으로 <strong>연속 메모리 할당 방식</strong>을 사용한다. 연속 메모리 할당 방식에도 3가지의 방법이 존재한다. 그리고 Compaction 까지도 사용하지만 문제가 생기기 때문에 Paging이 나오게 된다.</p>

<ul>
  <li>최초 적합(First-fit): 메모리를 순차적으로 탐색하여 제일 먼저 발견한 적절하게 들어갈 수 있는 곳을 찾아 프로세스를 적재하는 방법이다.</li>
  <li>최적 적합(Best-fit): 메모리를 탐색하여 메모리 공간 중에서 제일 적절하게 들어갈 수 있는 곳을 찾아 프로세스를 적재하는 방법이다.</li>
  <li>최악 적합(Worst-fit): 메모리에 넣는데 크기와 제일 안 맞는 공간(프로세스보다 큰 메모리 공간 중에서)에 프로세스를 넣는 방식이다.</li>
  <li>Compaction: hole 들을 한 곳으로 모으겠다는 방식
    <ul>
      <li>하지만 메모리를 계산해서 움직여야 하기 때문에 부담이 크다</li>
    </ul>
  </li>
</ul>

:ET