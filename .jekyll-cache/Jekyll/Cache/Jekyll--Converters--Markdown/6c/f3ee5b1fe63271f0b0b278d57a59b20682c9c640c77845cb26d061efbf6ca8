I"<h1 id="spring-jpa-2">Spring JPA 2</h1>
<hr />

<h2 id="-entity-mapping">💿 Entity Mapping</h2>

<h3 id="entity">@Entity</h3>

<ul>
  <li>Entity는 객체 관점에서 부르는 이름</li>
  <li>보통 Class와 같은 이름을 사용하기 때문에 값을 변경하지 않음</li>
  <li>Entity의 이름은 JQL에서 사용</li>
</ul>

<h3 id="table">@Table</h3>

<ul>
  <li>Relation(database) 관점에서 부르는 이름</li>
  <li>@Entity의 이름이 기본값</li>
  <li>Table의 이름은 SQL에서 사용</li>
</ul>

<h3 id="id">@Id</h3>

<ul>
  <li>Entity의 Primary Key를 매핑할 떄 사용</li>
  <li>java의 모든 primitive 와 Wrapper 타입 사용 가능
    <ul>
      <li>Date랑 BigDecimal, BigInteger도 사용가능</li>
    </ul>
  </li>
  <li>복합키를 만들어 매핑하는 방법도 있긴 있음</li>
</ul>

<h3 id="generativevalue">@GenerativeValue</h3>

<ul>
  <li>Primary Key의 생성 방법을 매핑하는 Annotation</li>
  <li>생성 전략과 생성기를 생성할 수 있음
    <ul>
      <li>기본 전략: AUTO(DB에 따라 적절한 전략 선택)</li>
      <li>TABLE, SEQUENCE, IDENTITY 중 하나</li>
    </ul>
  </li>
</ul>

<h3 id="column">@Column</h3>

<ul>
  <li>unique, nullable, length, ColumnDefinition 등 Row의 특성 정의</li>
</ul>

<h3 id="temporal">@Temporal</h3>

<ul>
  <li>Date 와 Calendar</li>
</ul>

<h3 id="transient">@Transient</h3>

<ul>
  <li>Column으로 매핑하고 싶지 않은 멤버 변수에 사용</li>
</ul>

<p><strong>Tip</strong></p>

<ul>
  <li>spring.jpa.show-sql=true</li>
  <li>spring.jpa.properties.hibernate.format_sql=true</li>
</ul>

<hr />

<h2 id="-value-타입-매핑">💿 @Value 타입 매핑</h2>

<h3 id="entity-와-value">Entity 와 Value</h3>

<ul>
  <li>식별자가 있어야 하는가</li>
  <li>독립적으로 존재해야 하는가</li>
</ul>

<h3 id="value-타입-종류">Value 타입 종류</h3>

<ul>
  <li>기본 타입(String, Date, Boolean)</li>
  <li>Composite Value 타입</li>
  <li>Collection Value 타입
    <ul>
      <li>기본 타입의 콜렉션</li>
      <li>Composite 타입의 콜렉션</li>
    </ul>
  </li>
</ul>

<h3 id="composite-value-타입">Composite Value 타입</h3>

<ul>
  <li>@Embedable</li>
  <li>@Embedded</li>
  <li>@AttributeOverrides</li>
  <li>AttributeOverride</li>
</ul>

<hr />

<h2 id="-관계-매핑">💿 관계 매핑</h2>

<ul>
  <li>2개의 Entity의 관계를 설정
    <ul>
      <li>둘 중 하나는 관계의 주인이 되어야 함</li>
      <li>다른 쪽은 종속된 쪽</li>
      <li>해당 관계의 반대쪽 레퍼런스를 가진 쪽이 주인</li>
    </ul>
  </li>
  <li>단방향
    <ul>
      <li>단방향에서는 관계의 주인이 명확
        <ul>
          <li>관계를 정의한 쪽이 관계의 주인</li>
        </ul>
      </li>
      <li>단방향 @ManyToOne
        <ul>
          <li>기본값은 FK 생성</li>
        </ul>
      </li>
      <li>단방향 @OneToMany
        <ul>
          <li>기본값은 조인 테이블 생성</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>양방향
    <ul>
      <li>FK를 가지고 있는 쪽이 Owner 따라서 @ManytoOne 가지고 있는 쪽이 주인</li>
      <li>주인이 아닌 쪽은 mappedby를 통해 필드를 설정
        <ul>
          <li>@ManyToOne(이쪽이 주인)</li>
          <li>@OneToMany(mappedby)</li>
          <li>주인에게 관계를 설정해야 DB에 반영이 됨(중요)
            <ul>
              <li>mappedby쪽에 더해서 save해도 DB 적용 안됨</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<hr />

<h2 id="-entity-상태와-cascade">💿 Entity 상태와 Cascade</h2>

<blockquote>
  <p>Cascade: Entity의 상태를 전이 시키는 옵션</p>
</blockquote>

<h3 id="entity의-상태">Entity의 상태</h3>

<ul>
  <li>Transient: JPA가 모르는 상태</li>
  <li>Persistent: JPA가 관리중인 상태(1차 캐쉬, Dirty-Checking, WriteBehind)</li>
  <li>Detached: JPA가 더이상 관리하지 않는 상태</li>
  <li>Removed: JPA가 관리하긴 하지만 삭제하기로 한 상태</li>
</ul>

<p><img src="https://blog.kakaocdn.net/dn/biYa6T/btqCuYYCtXY/Bxqa5rHj3s4Rz33PQDmJFK/img.jpg" alt="image" /></p>

<hr />

<h2 id="entity-fetch-join">Entity Fetch Join</h2>

<ul>
  <li>연관된 Entity를 함께 조회</li>
  <li>select m from Member m join fetch m.team
    <ul>
      <li>SQL: Select M.<em>,T.</em> FROM MEMBER M INNER JOIN TEAM T on M.TEAM_ID=T.ID</li>
    </ul>
  </li>
</ul>
:ET