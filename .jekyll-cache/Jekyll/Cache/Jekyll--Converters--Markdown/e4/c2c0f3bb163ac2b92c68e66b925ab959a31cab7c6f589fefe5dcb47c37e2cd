I"&<h1 id="java-basics">Java Basics</h1>
<hr />

<h2 id="data-type">Data Type</h2>

<p><img src="https://lh3.googleusercontent.com/proxy/mBv-_PCXtzdH04OSePTct032YU4ZT3H_ENcQxlNBvzIZ5HHBVm5mMnqJ-6q9q7LSa9nCbygSTGo6M0IvowB-IWcP8Fdg0a7oI53GdB_rlY3nED208N7Sx-SEHlLRo8eeCCA93lN8AXIB6SE8foucHOfk53mYKMbuNQ" alt="image" /></p>

<p><strong>메모리에 집접 담는가?</strong></p>
<ul>
  <li>Primitive Type(기본형): 직접 데이터를 담음</li>
  <li>Reference Type(참조형): 메모리를 참조</li>
</ul>

<h2 id="primitive-type기본형">Primitive Type(기본형)</h2>

<ul>
  <li>총 8가지의 기본형 타입(Primitive type)을 미리 정의하여 제공</li>
  <li>기본값이 있기 때문에 Null이 존재하지 않는다. 만약 기본형 타입에 Null을 넣고 싶다면 래퍼 클래스를 활용</li>
  <li>실제 값을 저장하는 공간으로 스택(Stack) 메모리에 저장된다.</li>
  <li>Java에는 C 처럼 Sizeof가 없으나 Primitive Type 클래스가 존재하고 그 안에 각 타입의 크기를 명시</li>
</ul>

<p><img src="https://loustler.io/files/java_primitive_type.png" alt="image" /></p>
<div style="text-align: center">출처: https://loustler.io/languages/Java-primitive-type/</div>

<h2 id="reference-type참조형">Reference Type(참조형)</h2>

<blockquote>
  <p>기본적으로 java.lang.Object를 상속</p>
</blockquote>

<ul>
  <li>클래스형: 객체를 참조 하는 타입</li>
  <li>인터페이스형: 상수(static final)와 추상 메서드(abstract method)의 집합
    <ul>
      <li>생성자를 가질 수 없음</li>
      <li>객체화 불가</li>
      <li>다중 상속 가능</li>
      <li>자바8 부터 인터페이스에 디폴트 메서드(default method)를 지원</li>
    </ul>
  </li>
</ul>

<h2 id="literal">Literal</h2>

<blockquote>
  <p>데이터 그 자체</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>여기서 1이 리터널</p>

<h2 id="변수-선언-및-초기화">변수 선언 및 초기화</h2>

<ul>
  <li>명시적 초기화: 변수 선언과 동시에 초기화
    <ul>
      <li>int a = 3;</li>
      <li>ClassA a = new ClassA();</li>
    </ul>
  </li>
  <li>초기화 블럭
    <ul>
      <li>클래스 초기화 블럭
        <ul>
          <li>클래스를 초기화 하는데 사용</li>
          <li>클래스가 처음 메모리에 로딩 될 때 한번만 수행</li>
        </ul>
      </li>
      <li>인스턴스 초기화 블럭
        <ul>
          <li>인스턴스 변수를 초기화 하는데 사용</li>
          <li>생성자와 같이 인스턴스가 생성될 때 수행</li>
          <li>인스턴스 초기화 블럭이 생성자보다 먼저 수행</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>  <span class="kd">class</span> <span class="nc">A</span> <span class="o">{</span>
    <span class="c1">// 클래스 초기화 블럭</span>
    <span class="kd">static</span> <span class="o">{</span>
      <span class="o">...</span>
    <span class="o">}</span>
    <span class="c1">// 인스턴스 초기화 블럭</span>
    <span class="o">{</span>
      <span class="o">...</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행해야 되는 코드를 삽입</p>

<p><strong>순서</strong></p>
<ul>
  <li>클래스 변수(static)
    <ul>
      <li>기본값 -&gt; 명시적 초기화 -&gt; 클래스 초기화 블럭</li>
    </ul>
  </li>
  <li>인스턴스 변수
    <ul>
      <li>기본값 -&gt; 명시적 초기화 -&gt; 인스턴스 초기화 블럭 -&gt; 생성자</li>
    </ul>
  </li>
</ul>

<h2 id="변수의-스코프와-라이프타임">변수의 스코프와 라이프타임</h2>

<p><strong><em>스코프</em></strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>  <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValableScopeExam</span><span class="o">{</span>

      <span class="kt">int</span> <span class="n">globalScope</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>   <span class="c1">// 인스턴스 변수 </span>

      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">scopeTest</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">){</span>   
          <span class="kt">int</span> <span class="n">localScope</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">globalScope</span><span class="o">);</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">localScpe</span><span class="o">);</span>
          <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>클래스의 속성으로 선언된 변수 globalScope 의 사용 범위는 클래스 전체</li>
  <li>매개변수로 선언된 int value 는 블럭 바깥에 존재하기는 하지만, 메서드 선언부에 존재하므로 사용범위는 해당 메소드 블럭 내</li>
  <li>메소드 블럭내에서 선언된 localScope 변수의 사용범위는 메소드 블럭 내</li>
</ul>

<p><strong><em>lifetime</em></strong></p>

<ul>
  <li>전역: app 실행 동안 유지</li>
  <li>정적(static): app 실행 동안 유지</li>
  <li>자동/지역: 함수 실행 동안 유지</li>
  <li>동적: 메모리 해제 전까지 유지</li>
</ul>

<h2 id="타입-변환-캐스팅-그리고-타입-프로모션">타입 변환, 캐스팅 그리고 타입 프로모션</h2>

<p><strong>타입 변환, 캐스팅</strong></p>

<ul>
  <li>묵시적 변환(Promotion)
    <ul>
      <li>큰 타입에 저장할 때 큰 타입으로 변환</li>
      <li>float a = 10;</li>
    </ul>
  </li>
  <li>강제 변환(casting)
    <ul>
      <li>값 손실 발생</li>
      <li>char a = (char)65</li>
    </ul>
  </li>
</ul>

<h2 id="1차-및-2차-배열-선언하기">1차 및 2차 배열 선언하기</h2>

<ul>
  <li>1차원 배열
    <ul>
      <li>int []a = new int[10];</li>
      <li>int a[] = new int[10];</li>
      <li>int a[] = {1,2,3,4,5}</li>
      <li>new int[] {1,2,3,4,5} // 매개변수</li>
    </ul>
  </li>
  <li>2차원 배열
    <ul>
      <li>int [][]a = new int[10][10];</li>
      <li>for() 으로 초기화</li>
    </ul>
  </li>
</ul>

<h2 id="타입-추론">타입 추론</h2>

<ul>
  <li>ex) var list = new ArrayList<String>();</String></li>
  <li>initializer가 필수</li>
  <li>다이아몬드 연산자 사용 불가</li>
</ul>

<h2 id="접근-제어자">접근 제어자</h2>

<blockquote>
  <p>접근 제어자 - public, protected, default, private <br />
그 외 - static, final, abstract, transient, synchronized, volatile etc.</p>
</blockquote>

<ul>
  <li>접근 제어자 : 접근 제어자는 해당 클래스 또는 멤버를 정해진 범위에서만 접근할 수 있도록 통제하는 역할을 한다. 클래스는 public과 default밖에 쓸 수 없다. 범위는 다음과 같다. 참고로 default는 아무것도 덧붙이지 않았을 때를 의미한다.</li>
  <li>static : 변수, 메서드는 객체가 아닌 클래스에 속한다.</li>
  <li>final :
    <ul>
      <li>클래스 앞에 붙으면 해당 클래스는 상속될 수 없다.</li>
      <li>변수 또는 메서드 앞에 붙으면 수정되거나 오버라이딩 될 수 없다.</li>
    </ul>
  </li>
  <li>abstract :
    <ul>
      <li>클래스 앞에 붙으면 추상 클래스가 되어 객체 생성이 불가하고, 접근을 위해선 상속받아야 한다.</li>
      <li>변수 앞에 지정할 수 없다. 메서드 앞에 붙는 경우는 오직 추상 클래스 내에서의 메서드밖에 없으며 해당 메서드는 선언부만 존재하고 구현부는 상속한 클래스 내 메서드에 의해 구현되어야 한다. 상속과 관련된 내용은 6주차에 다룰 예정이다.</li>
    </ul>
  </li>
  <li>transient : 변수 또는 메서드가 포함된 객체를 직렬화할 때 해당 내용은 무시된다.</li>
  <li>synchronized : 메서드는 한 번에 하나의 쓰레드에 의해서만 접근 가능하다.</li>
  <li>volatile : 해당 변수의 조작에 CPU 캐시가 쓰이지 않고 항상 메인 메모리로부터 읽힌다.</li>
  <li>strictfp:
    <ul>
      <li>플랫폼에 상관없이 부동 소수점 연산에 일관성을 부여한다.</li>
      <li>클래스, 메소드, 인터페이스에 사용이 가능하다.</li>
    </ul>
  </li>
</ul>
:ET