I"<h1 id="spring-web">Spring Web</h1>
<hr />

<h2 id="url">URL</h2>

<ul>
  <li>get, post는 기본</li>
  <li>head: get과 같으나 header 정보만 가져옴</li>
  <li>options
    <ul>
      <li>사용할 수 있는 http Method 제공</li>
      <li>서버 또는 특정 리소스가 제공하는 기능을 확인</li>
      <li>서버 또는 allow 응답 헤더에 사용할 수 있는 http method 목록 제공</li>
    </ul>
  </li>
</ul>

<h2 id="controller">@Controller</h2>

<blockquote>
  <p>request를 담당하는 annotation RestController는 자동으로 responsebody에 객체를 담아준다.</p>
</blockquote>

<ul>
  <li>@RequestMapping: Responsebody가 있거나 RestController를 사용하지 않으면 반환되는 문자열에 해당하는 View를 return 하고 Class에다가 선언 시 method의 RequestMapping과 value가 합쳐서 경로가 결정된다.
    <ul>
      <li>value: request 경로 (uri 패턴 &amp; 정규식 지원),(추가 형식)</li>
      <li>method: handle할 method</li>
      <li>consumes: 사용할 MediaType 지정</li>
      <li>produces: 내보낼 MediaType 지정(overiding됨)</li>
      <li>headrs: headr가 선언된 조건식에 일치 하는가</li>
      <li>params: 코딩된 uriParam과 일치하는가</li>
      <li>유사: GetMapping, PostMapping…</li>
      <li>자동 확장자 매핑 불가</li>
    </ul>
  </li>
  <li>@RequestParams
    <ul>
      <li>argument에 사용: uri 패턴의 parameter를 가져옴</li>
      <li>WebRequest라는 매개변수를 통해 가져올 수 도 있음</li>
    </ul>
  </li>
  <li>@PathVariable
    <ul>
      <li>argument에 사용: path에 해당하는 값을 가져옴</li>
    </ul>
  </li>
</ul>

<h2 id="formatter">Formatter</h2>

<ol>
  <li>Formatter를 상속하여 Formatter Class로 overriding 함</li>
  <li>WebConfigurer를 상속한 Config Class에 addFormatter를 통해 등록</li>
</ol>

<h2 id="converter">Converter</h2>

<blockquote>
  <p>Formatter는 String 대상으로만 사용 가능 Converter는 클래스 대상으로도 사용 가능하다.</p>
</blockquote>

<ul>
  <li>또한 SpringJPA가 자동으로 등록해 주는 domain Class Converter는 id를 Entity에 매핑 시켜 준다.</li>
</ul>

<h2 id="handler-interceptor">Handler Interceptor</h2>

<ul>
  <li>preHandle(request, response, handler)
    <ul>
      <li>handler를 실행하기 전에 호출됨</li>
      <li>handler에 대한 정보를 사용할 수 있기 때문에 서블릿 필터에 비해 보다 세밀한 로직 구현</li>
      <li>리턴 값으로 계속 다음 interceptor 또는 handler 요청, 응답을 전달할지 응답처리가 	이곳에서 끝난지를 알림</li>
    </ul>
  </li>
  <li>postHandle(request, response, modelAndView)
    <ul>
      <li>핸들러 실행이 끝나고 뷰를 랜더링 하기 전에 호출됨</li>
      <li>뷰에 전달할 추가적이거나 여러 handler에 공통적인 모델 정보를 	담는데 사용할 수 있음</li>
      <li>비동기적인 요청 처리 시에는 호출되지 않습니다.</li>
    </ul>
  </li>
  <li>afterCompletion(request, response, handler, ex)
    <ul>
      <li>요청 처리가 완전히 끝난 뒤(뷰 렌더링이 끝난 후) 호출 됨</li>
      <li>preHandler에서 true를 return한 경우에만 호출 됨</li>
      <li>비동기적 요청처리에는 호출되지 않음</li>
    </ul>
  </li>
  <li>순서
    <ol>
      <li>prehandle 1</li>
      <li>prehandle 2</li>
      <li>요청처리</li>
      <li>posthandle 2</li>
      <li>posthandle 1</li>
      <li>뷰렌더링</li>
      <li>aftercompletion 2</li>
      <li>aftercompletion 1</li>
    </ol>
  </li>
  <li>서블릿 보다 구체적인 처리 가능</li>
  <li>서블릿 보다 일반적인 용도의 기능을 구현</li>
</ul>

<h3 id="구현">구현</h3>

<ul>
  <li>HandlerInterceptor implement 해서 사용</li>
  <li>webMvcConfigurer 상속 클래스에 addInterceptor을 통해 등록
    <ul>
      <li>order함수를 통해 순서 지정</li>
      <li>addPathPatterns를 통해 특정 경로에만 match</li>
    </ul>
  </li>
</ul>

<h2 id="리소스-핸들러">리소스 핸들러</h2>

<ul>
  <li>Default Servlet
    <ul>
      <li>Servlet Container가 기본적으로 제공하는 Servlet으로 정적인 Resource 처리할 때 사용</li>
    </ul>
  </li>
  <li>Spring MVC Resource Handler 등록
    <ul>
      <li>가장 낮은 순위로 등록
        <ul>
          <li>다른 Handler Mapping이 “/”이하 요청을 처리 허용</li>
          <li>최종적으로 resource Handler가 처리</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>설정
    <ul>
      <li>어떤 요청 패턴 지원할 것인가</li>
      <li>어디서 리소스를 찾을 것인가</li>
      <li>캐쉬</li>
      <li>Resource Resolver: 요청에 해당하는 Resource를 찾는 전략
        <ul>
          <li>Caching, Encoding, WebJar</li>
        </ul>
      </li>
      <li>ResourceTransformer: 응답으로 보낼 리소스를 수집하는 전략
        <ul>
          <li>Caching, CSS 링크, HTML5,</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>SpringBoot가 기본적인 핸들러 캐싱 제공</li>
</ul>

<h2 id="http-message-converter">Http Message Converter</h2>

<blockquote>
  <p>요청 본문에서 메세지를 읽거나 응답 본문에 메세지를 작성할 때 사용 jackson같은거</p>
</blockquote>

<h2 id="arguments">Arguments</h2>

<ul>
  <li>PushBuilder: 요청이 오면 필요한 리소스를 요청하지 않아도 보내는 기술</li>
  <li>HttpMethod: 요청의 method를 가져옴</li>
  <li>HttpSession: 세션 이용</li>
  <li>많이 있으니까 doc 참고</li>
</ul>

<h2 id="modelattributes">@ModelAttributes</h2>

<ul>
  <li>Request로 넘어오는 여러가지 데이터들을 복합타입 객체로 받아오거나 새로 만들 때 사용</li>
  <li>값을 바인딩 할 수 없을 땐 BindException 발생
    <ul>
      <li>직접 Exception 처리할 땐 BindingResult 타입의 argument</li>
    </ul>
  </li>
  <li>@Valid를 통해 검증 작업 진행 가능</li>
  <li>
    <p>Session에서 먼저 찾아서 바인딩 하고 queryparam에서 바인딩 하는데 키가 중복될 경우 session에서 못찾으면 에러가 난다.</p>
  </li>
  <li>Validated의 경우 Valid그룹 지정 가능</li>
</ul>

<h2 id="sessionattributes">@SessionAttributes</h2>

<blockquote>
  <p>Controller 안에서 공용으로 사용할 객체를 세션에 담아서 공유</p>
</blockquote>

<ul>
  <li>요청 정보를 Http세션에 저장
    <ul>
      <li>직접사용하여 저장</li>
      <li>이름을 설정해서 해당하는 모델 자동으로 세션에 저장</li>
      <li>@ModelAttribute는 세션에 있는 데이터 바인딩
        <ul>
          <li>요청을 따로 보낼 필요가 없다(Form이 나눠져 있을 때)</li>
        </ul>
      </li>
      <li>여러 요청에 사용하는 객체를 공유해야 할 때 사용</li>
    </ul>
  </li>
  <li>SessionStatus를 사용해서 세션 처리 완료 가능
    <ul>
      <li>폼 처리 끝나고 세션 비울때</li>
    </ul>
  </li>
</ul>

<h2 id="sessionattribute">@SessionAttribute</h2>

<blockquote>
  <p>Controller 외부에서(Servlet 등등)에서 저장한 세션값을 가져오고 싶을 때</p>
</blockquote>

<ul>
  <li>argument에 선언해서 사용한다.</li>
</ul>

<h2 id="redirectattributes">RedirectAttributes</h2>

<ul>
  <li>Model의 경우 모든 값은 Redirect 시 자동으로 queryParameter로 등록 됨
    <ul>
      <li>SpringBoot는 이 기능을 꺼놨음</li>
    </ul>
  </li>
  <li>Model 대신에 RedirectAttriburtes 사용하면 됨</li>
  <li>addflashAttributes를 할 경우 자동으로 세션으로 등록후 Redirect 끝날 때 자동으로 세션 초기화
    <ul>
      <li>받을 때 model.asMap().get(“키”)</li>
    </ul>
  </li>
</ul>

<h2 id="multipartfile">MultipartFile</h2>

<ul>
  <li>MultipartFile 타입의 매개변수로 받음</li>
  <li>MulipartResolver가 없으면 안됨</li>
  <li>max크기등을 설정할 수 있음(application.properties)</li>
</ul>
:ET