I"<h1 id="operation-system-6페이징">Operation System 6(페이징)</h1>
<hr />

<h2 id="-가상-메모리">💿 <strong>가상 메모리</strong></h2>

<blockquote>
  <p>메모리 과할당(over allocation) 즉 실제 메모리의 사이즈 보다 더 큰 사이즈의 메모리를 프로세스에 할당하기 위한 방법</p>
</blockquote>

<p>프로세스의 모든 코드는 항상 필요한 것이 아니다.</p>

<p>필요한 부분만 메모리에 올림으로써 메인 메모리에 올라가는 프로세스의 크기를 줄인다.(동적 적재와 비슷)</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/22430F4E590E8ADA1C" alt="image" /></p>

<ol>
  <li>페이징을 먼저 실행
    <ul>
      <li>메인 메모리의 외부 단편화를 해결하면 효율적이기 때문</li>
    </ul>
  </li>
  <li>여기서 필요한 부분과 필요없는 부분을 나눈다.</li>
  <li>필요한 부분만 메모리에 적재</li>
</ol>

<p>이를 요구 페이징이라고 한다.</p>

<p>요구페이징은 프로세스의 이미지를 backing store에 저장한다. backing store는 swap device로 하드웨어의 부분인데 페이즈를 임시로 보관하는 공간이다.</p>

<p>프로세스는 페이지의 조합인데 요구되는 페이지만 메모리에 올린다 하여 요구 페이징이라 불린다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/224F144E590E8AD91B" alt="image" /></p>

<p>MMU의 재배치 레지스터를 통해 논리 주소를 물리 주소로 바꾸어주는 주소 변환 과정을 거쳐 CPU가 프로세스는 연속적으로 할당되어져 있다고 속게 만드는 작업을 한다.</p>

<p>그런데 요구 페이징 기법을 사용하면 페이지가 메모리에 올라와있는 것도 있고 올라가지 않고 backing store에 보관되어 있는 것도 존재한다.</p>

<p>따라서 페이지 테이블을 작성할 때 이를 구분해줄 도구가 필요하다. 그래서 valid 비트 필드를 페이지 테이블에 추가한다. 1과 0의 값으로 메모리에 적재되어 있는지 없는지를 구분할 수 있다.</p>

<p><img src="https://t1.daumcdn.net/cfile/tistory/2756414E590E8AD922" alt="image" /></p>

<p>CPU에서 해당 메모리를 가져오라고 논리 주소를 보냈는데 페이지 테이블에서 접근하려는 페이지가 메모리에 없다고 표시가 되어 있다.</p>

<p>이는 valid 비트 필드에 의해서 결정된다.</p>

<p>CPU에서 해당 메모리를 가져오라고 논리 주소를 보냈는데 페이지 테이블에서 접근하려는 페이지가 메모리에 없다면 Backing store에서 해당 페이지를 가져와야한다.</p>

<p>이를 수행하기 위해서 CPU는 잠시 하는 일을 멈추고 운영체제가 나서서 Backing store를 뒤져 필요한 페이지를 적재한다. 그리고 valid 비트를 올라와 있다고 바꾸어 준다. 이런 현상을 페이지 결함, 페이지 부재(Page Fault)라고 부른다.</p>

<p><strong>요구페이징</strong></p>
<ul>
  <li>처음부터 모든 페이지를 적재시키지 않고 CPU가 요구할 때 valid를 바꾸어 페이지를 적재하는 방법</li>
  <li>우선 필요할 것 같은 페이지를 적재시키고 필요할 때 다른 페이지를 적재시키는 방법이 있다.</li>
</ul>

<h2 id="-유효-접근-시간과-지역성">💿 <strong>유효 접근 시간과 지역성</strong></h2>

<h3 id="유효-접근-시간"><strong>유효 접근 시간</strong></h3>

<blockquote>
  <p>유효 접근 시간: Effective Access Time으로 평균적으로 CPU가 요구할 때 메모리를 통해 읽혀지는 시간</p>
</blockquote>

<p>어떤 프로세스의 경우 메인 메모리에 올라와 있으면 바로 읽어서 시간일 짧을 것이고 어떤 프로세스의 경우 backing store에서 메인 메모리로 올려줘야 하는 경우 CPU도 중단시켜야하고 운영체제가 찾아서 올리는 과정까지 해서 시간이 많이 걸릴 것이다. 그래서 페이지 결함이 일어날 확률을 통해 유효 접근 시간을 구하게 된다.</p>

<p>유효 접근 시간을 수학적인 식으로 구하게 되면 다음과 같다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre>Teff = (1-p)Tm + pTp
</pre></td></tr></tbody></table></code></pre></div></div>

<p>유효 접근 시간은 메모리에 존재하는 페이지와 메모리에 존재하지 않는 페이지의 접근 시간의 평균으로 구한다고 했다.</p>
<ul>
  <li>p: 페이지가 결함이 일어날 확률이다. 따라서 1-p는 페이지가 결함이 일어나지 않을 확률이다.</li>
  <li>Tm: 메인 메모리에서 바로 CPU가 실행할 수 있는 시간을 의미하고</li>
  <li>Tp는 운영체제가 backing store인 하드디스크에서 페이지를 찾고 메모리에 올리고 실행시키는 시간을 의미한다.
    <ul>
      <li>seek time, rotational delay, transfer time</li>
      <li>여기서 seek time: 하드디스크에서 찾아가는 시간으로 가장 오래 걸리는 부분을 차지한다.</li>
    </ul>
  </li>
</ul>

<p>당연히 Tp가 Tm에 비해 걸리는 시간이 많은 것이다.</p>

<p>따라서 각각의 확률에 시간을 곱한 후 더하게 되면 평균적으로 페이지를 접근하는데 걸리는 시간이 나오게 된다.</p>

<p>Tp가 유효 접근 시간에 큰 영향을 끼치므로 페이지 결함을 줄여야 컴퓨터의 효율이 올라가게 된다.</p>

<h3 id="지역성"><strong>지역성</strong></h3>

<blockquote>
  <p>CPU가 참조하는 주소가 지역에 모여져 있다.</p>
</blockquote>

<ul>
  <li>시간적인 지역성: 한 번 읽었던 코드를 다시 읽을 확률이 높다는 것을 의미한다.
    <ul>
      <li>코드 중에는 while문이나 for문과 같이 같은 구간을 반복하는 명령이 존재하기 때문이다. 이 때 맨 처음에 페이지를 메인 메모리에 적재한 후에는 다시 적재할 필요가 없기 때문에 페이지 결함의 확률이 매우 낮다.</li>
    </ul>
  </li>
  <li>공간적인 지역성: 코드를 읽을 때 현재 코드의 주변에 있는 코드를 읽을 확률이 높다는 것
    <ul>
      <li>페이지 결함이 일어나 하드디스크에서 페이지를 가져올 때 주변 코드들을 block 단위로 가져오게 되면 주변 코드를 읽을 확률이 높으니 다음의 페이지 결함의 확률이 낮아지는 것이다.</li>
      <li>따라서 지역성의 원리에 의해 페이지 결함으로 인한 컴퓨터의 효율이 떨어지는 확률이 많이 낮아진다.</li>
    </ul>
  </li>
</ul>

:ET