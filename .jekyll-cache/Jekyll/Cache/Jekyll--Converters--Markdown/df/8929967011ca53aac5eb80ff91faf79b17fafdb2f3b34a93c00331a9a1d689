I")<h1 id="operation-system-6파일-시스템">Operation System 6(파일 시스템)</h1>
<hr />

<h2 id="-파일">💿 <strong>파일</strong></h2>

<blockquote>
  <p>운영체제의 저장장치의 물리적 특성을 추상화한 논리적 저장 단위</p>
</blockquote>

<p>파일은 운영체제에 의해 물리 장치들로 맵핑되기도 하며,</p>

<p>일반적으로 비휘발적 특성을 지니기 때문에, 전원이 끊어진 상황에서도 정보들을 영구히 보존할 수 있다</p>

<ul>
  <li>프로그램 : 소스 프로그램, 목적 프로그램으로 나누어 진다.</li>
  <li>자료 : 숫자,문자,이진수, 자유 형식이거나 정해진 형식 등, 저장할 수 있는 모든 것이 자료가 될 수 있다.</li>
</ul>

<h3 id="파일-속성"><strong>파일 속성</strong></h3>

<ul>
  <li>이름 : 사람이 읽을 수 있는 형태로 유지되는 유일한 정보</li>
  <li>식별자 : 파일 시스템 내에서 파일을 식별하는 고유의 번호 PK</li>
  <li>타입 : 여러 타입의 파일을 제공하는 시스템을 위해 필요</li>
  <li>위치 : 장치 내에서 파일의 위치를 가리키는 포인터</li>
  <li>크기 : 파일의 현재 크기</li>
  <li>보호 : 접근 제어 정보</li>
  <li>시간, 날짜, 사용자 식별 : 생성, 최근 변경, 최근 사용 등에 대한 정보
모든 파일에 대한 정보는 보조 저장장치에 상주하는 디렉토리 구조 내에 유지된다.
    <ul>
      <li>파일과 디렉터리 모두 비휘발적 성질을 가져야 하므로, 저장 장치 상에 저장되고, 필요할 때 조금씩 메모리로 가져와야 한다.</li>
    </ul>
  </li>
</ul>

<h3 id="파일-연산"><strong>파일 연산</strong></h3>

<ul>
  <li>파일 생성 : 사용할 수 있는 공간을 찾고 파일을 할당한다, 또한 파일이 디렉터리에 만들어져야 한다.</li>
  <li>파일 쓰기 : 파일 이름과 기록될 정보를 명시하는 시스템 콜을 호출한다.
    <ul>
      <li>시스템은 파일 내의 다음 쓰기가 일어날 위치를 가리키는 쓰기 포인터를 유지하고 있어야 한다.</li>
      <li>쓰기 포인터는 쓰기가 일어날 때마다 갱신된다.</li>
    </ul>
  </li>
  <li>파일 읽기 : 파일 이름과 피일이 읽혀 들어갈 블록의 위치를 명시하는 시스템 콜을 호출한다.
    <ul>
      <li>다음 읽기가 일어날 파일 안의 위치를 기록하는 읽기 포인터를 유지해야 한다.</li>
      <li>프로세스는 일반적으로 파일 읽기 나 파일 쓰기 중 한 가지를 하고 있기 때문에, 대부분의 시스템은 한 개의 현재 파일 위치 포인터 를 가진다. 읽기,쓰기 연산 모두 이 포인터를 이용하여 공간을 절약하고, 복잡성을 감소시킨다.</li>
    </ul>
  </li>
  <li>파일 안에서의 위치 재설정 : 디렉터리에서 적합한 항목을 탐색하고, 현재 파일 위치를 주어진 값으로 설정한다.</li>
  <li>파일 삭제 : 지명된 파일을 디렉터리에서 찾는다, 발견하면 파일이 차지하는 공간을 방출하고 디렉터리 항목을 삭제한다.</li>
  <li>파일 절단 : 파일의 내용을 지우고, 속성만을 남긴다.
위에 있는 6개의 연산은 파일 조작에 필요한 최소한의 연산이다.
    <ul>
      <li>새로운 정보를 추가하는 첨가(appending) 나 재명명(renaming) 등이 더 있다.</li>
      <li>운영체제는 모든 열린 파일에 대한 정보를 갖는 열린 파일 테이블(open file table) 을 유지한다.</li>
      <li>시스템 콜 open()은 전형적으로 열린 파일 테이블의 항목에 대한 포인터를 리턴한다.</li>
    </ul>
  </li>
</ul>

<h3 id="다중-프로세스-환경"><strong>다중 프로세스 환경</strong></h3>

<blockquote>
  <p>다중 프로세스 환경에서는 open()과 close() 연산의 구현은 더 복잡한데, 보통 운영체제는 프로세스별 테이블과 범 시스템 테이블을 사용한다.</p>
</blockquote>

<ul>
  <li>프로세스 별 테이블: 파일 포인터, 접근 권한</li>
  <li>범 시스템 테이블: 프로세스에 독립적인 정보들 : 디스크 상의 파일 위치, 접근 날짜, 크기</li>
</ul>

<h3 id="오픈-파일-테이블"><strong>오픈 파일 테이블</strong></h3>

<p>파일이 하나의 프로세스에 의해 열려 있다.</p>

<p>이때 다른 프로세스가 open()을 호출한 경우 오픈 파일 테이블에 범 시스템 테이블 에 있는 정보를 가리키는 새로운 포인터가 생긴다.</p>

<p>일반적으로 오픈 파일 테이블은 파일을 연 프로세스 수를 가리키는 오픈 계수 (open count)를 각 파일에 연관지어 둔다. close() 콜은 이 오픈 계수를 감소시키고 계수가 0이 되면 해당 정보를 테이블에서 제거한다.</p>

<hr />

<h2 id="-파일-시스템">💿 <strong>파일 시스템</strong></h2>

<blockquote>
  <p>컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록 유지 및 관리하는 방법</p>
</blockquote>

<h3 id="특징"><strong>특징</strong></h3>

<ul>
  <li>커널 영역에서 동작</li>
  <li>파일 CRUD 기능을 원할히 수행하는 목적</li>
  <li>계층적 디렉터리 구조를 가짐</li>
  <li>디스크 파티션 별로 하나씩 있음</li>
</ul>

<h3 id="역할"><strong>역할</strong></h3>

<ul>
  <li>파일 관리</li>
  <li>보조 저장소 관리</li>
  <li>파일 무결성 매커니즘</li>
  <li>접근 방법 제공</li>
</ul>

<h3 id="개발-목적"><strong>개발 목적</strong></h3>

<ul>
  <li>하드디스크와 메인 메모리 속도차를 줄이기 위함</li>
  <li>파일 관리</li>
  <li>하드디스크 용량의 효율적 이용</li>
</ul>

<h3 id="구조"><strong>구조</strong></h3>

<ul>
  <li>메타 영역: 데이터 영역에 기록된 파일 이름, 위치, 크기, 시간정보, 삭제유무 등의 파일 메타 정보</li>
  <li>데이터 영역: 파일의 데이터</li>
</ul>

<hr />

<h2 id="-접근-방법">💿 <strong>접근 방법</strong></h2>

<h3 id="순차-접근"><strong>순차 접근</strong></h3>

<blockquote>
  <p>가장 간단한 방법으로 대부분 연산은 read 와 write</p>
</blockquote>

<p><img src="https://camo.githubusercontent.com/3d98ce630359f31bcff0c3741e2a230ef161c4d6239803e722ca054a7a981751/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e312e706e67" alt="image" /></p>

<p>현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read 와 write를 진행 뒤로 돌아갈 땐 지정한 offset 만큼 되감기를 해야 한다.(테이프 모델 기반)</p>

<h3 id="직접-접근"><strong>직접 접근</strong></h3>

<blockquote>
  <p>특별한 순서없이, 빠르게 레코드를 read, write 가능</p>
</blockquote>

<p><img src="https://camo.githubusercontent.com/7561e732c8eec57fe126bce5f3d2f8e5dfd8cd7d2210eb275d249699db15f0d6/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e322e706e67" alt="image" /></p>

<p>현재 위치를 가리키는 cp 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현 가능</p>

<p>무작위 파일 블럭에 대한 임의 접근을 허용한다. 따라서 순서의 제약이 없음</p>

<p>대규모 정보를 접근할 때 유요하기 때문에 데이터베이스 에서 활용됨</p>

<h3 id="기타-접근"><strong>기타 접근</strong></h3>

<blockquote>
  <p>파일에서 레코드를 찾기 위해서 이 색인 부터 찾아 그에 대응하는 포인터를 얻는다 그런 다음 그 포인터를 사용하여 파일에 직접 접근하여 원하는 레코드를 얻는다.</p>
</blockquote>

<p><img src="https://camo.githubusercontent.com/47fc4842a54b5e76f61a6a6dd6e3403a223f3d51c22ad2dad9f08a68e3cfd2ac/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e332e706e67" alt="image" /></p>

<hr />

<h2 id="-디렉터리와-디스크-구조">💿 <strong>디렉터리와 디스크 구조</strong></h2>

<h3 id="1단계-디렉터리"><strong>1단계 디렉터리</strong></h3>

<blockquote>
  <p>파일들은 서로 유일한 이름을 가짐. 서로 다른 사용자라도 같은 이름 사용 불가</p>
</blockquote>

<p><img src="https://camo.githubusercontent.com/64e17df3257a6613a4dd3785c29992e5a11b5d3ad2921335bf79c3a7c69f959e/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e352e706e67" alt="image" /></p>

<h3 id="2단계-디렉터리"><strong>2단계 디렉터리</strong></h3>

<blockquote>
  <p>사용자 별 개별적인 디렉터리 만들어줌</p>
</blockquote>

<ul>
  <li>UFD : 자신만의 사용자 파일 디렉터리</li>
  <li>MFD : 사용자의 이름과 계정번호로 색인되어 있는 디렉터리</li>
</ul>

<p><img src="https://camo.githubusercontent.com/481d06b7e5e499c43e916ea8412a130be2f6bbb5cad332d6f6d3e327a0acf0d1/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e362e706e67" alt="image" /></p>

<h3 id="트리구조-디렉터리"><strong>트리구조 디렉터리</strong></h3>

<blockquote>
  <p>2단계 에서 확장된 다단계 트리 구조</p>
</blockquote>

<p>한 비트를 활용하여 일반 파일인지 디렉터리 파일인지 구분</p>

<p><img src="https://camo.githubusercontent.com/84f459c97d762e85f623e5198699e8e2f6353eb4b97489390fac3f21bc012555/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e372e706e67" alt="image" /></p>

<h3 id="그래프-구조-디렉터리"><strong>그래프 구조 디렉터리</strong></h3>

<blockquote>
  <p>순환이 발생하지 않도록 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나 가비지 컬렉션을 이용한 전체 파일 시스템을 순회하고 접근 가능 한 모든 것을 표시</p>
</blockquote>

<p><img src="https://camo.githubusercontent.com/1bcf4d313ab3dd04f9c747a86e12943c1fe978758f85f6a8069cb018ff4f5198/68747470733a2f2f6e6f65702e6769746875622e696f2f323031362f30322f32332f313074682d66696c6573797374656d2f31302e392e706e67" alt="image" /></p>

<hr />

<h2 id="-파일-시스템-마운팅">💿 <strong>파일 시스템 마운팅</strong></h2>

<p><img src="https://noep.github.io/2016/02/23/10th-filesystem/10.10.png" alt="image" />
<img src="https://noep.github.io/2016/02/23/10th-filesystem/10.11.png" alt="image" /></p>
:ET